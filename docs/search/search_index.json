{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"spangle \u00b6 spangle is a small and flexible ASGI application framework for modern web. Note spangle is on pre-alpha stage, so any updates may contain breaking changes. Getting Started \u00b6 Install \u00b6 Python>=3.9 is required. pip install spangle pip install hypercorn # or your favorite asgi server Get development version: pip install -e git+https://github.com/tkamenoko/spangle@develop Example \u00b6 # hello.py import spangle api = spangle . Api () @api . route ( \"/\" ) class Index : async def on_request ( self , req , resp ): resp . set_status ( 418 ) . set_text ( \"Hello world!\" ) return resp hypercorn hello:api Features \u00b6 Components with dependencies Flexible URL params Jinja2 built-in support Uniformed API Single page application friendly \u2026and more features. Take tutorials and see features ! Contribute \u00b6 Contributions are welcome! New features Bug fix Documents Prerequisites \u00b6 Python>=3.9 git poetry Build \u00b6 # clone this repository. git clone http://github.com/tkamenoko/spangle.git # install dependencies. poetry install Test \u00b6 poetry run poe test Update API docs \u00b6 poetry run poe doc:build","title":"Home"},{"location":"#spangle","text":"spangle is a small and flexible ASGI application framework for modern web. Note spangle is on pre-alpha stage, so any updates may contain breaking changes.","title":"spangle"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#install","text":"Python>=3.9 is required. pip install spangle pip install hypercorn # or your favorite asgi server Get development version: pip install -e git+https://github.com/tkamenoko/spangle@develop","title":"Install"},{"location":"#example","text":"# hello.py import spangle api = spangle . Api () @api . route ( \"/\" ) class Index : async def on_request ( self , req , resp ): resp . set_status ( 418 ) . set_text ( \"Hello world!\" ) return resp hypercorn hello:api","title":"Example"},{"location":"#features","text":"Components with dependencies Flexible URL params Jinja2 built-in support Uniformed API Single page application friendly \u2026and more features. Take tutorials and see features !","title":"Features"},{"location":"#contribute","text":"Contributions are welcome! New features Bug fix Documents","title":"Contribute"},{"location":"#prerequisites","text":"Python>=3.9 git poetry","title":"Prerequisites"},{"location":"#build","text":"# clone this repository. git clone http://github.com/tkamenoko/spangle.git # install dependencies. poetry install","title":"Build"},{"location":"#test","text":"poetry run poe test","title":"Test"},{"location":"#update-api-docs","text":"poetry run poe doc:build","title":"Update API docs"},{"location":"SUMMARY/","text":"Home Introduction Routing HTTP Methods Request Response Component Lifespan Events Request Hooks Error Handling Static Files Test Client Advanced Features API","title":"SUMMARY"},{"location":"component/","text":"Component \u00b6 Component is an object shared in spangle app. It is useful to store database connections or global configurations. Define your components \u00b6 class MyComponent : # `__init__` must take no args except `self` . def __init__ ( self ): self . value = 42 api . register_component ( MyComponent ) Now, you are ready to use that component in your api . Use components in view-classes \u00b6 To use components in view classes, call use_component . from spangle import use_component @api . route ( \"/comp\" ) class UseComponent : async def on_get ( self , req , resp ): my_comp = use_component ( MyComponent ) assert my_comp . value == 42 Note According to The Twelve-FactorApp , every application process should be stateless. In other words, components should contain config or database connection, but not session data. Do not use a component as a datastore. Use components from another component \u00b6 A component can refer other components. class AnotherComp : async def startup ( self ): # `async` is optional. my_comp = use_component ( MyComponent ) Note There is no way to define the order of startup hooks. Do not expect that startup hooks of other components are already completed. Call use_component out of api context \u00b6 If you want to use components out of api context(like test environment), you can set context via api_ctx . api_ctx . set ( your_api ) component = use_component ( MyComponent ) Use Api instance as a component \u00b6 You can use Api instance in view classes or components by calling use_api . class Comp : def startup ( self ): api = use_api ()","title":"Component"},{"location":"component/#component","text":"Component is an object shared in spangle app. It is useful to store database connections or global configurations.","title":"Component"},{"location":"component/#define-your-components","text":"class MyComponent : # `__init__` must take no args except `self` . def __init__ ( self ): self . value = 42 api . register_component ( MyComponent ) Now, you are ready to use that component in your api .","title":"Define your components"},{"location":"component/#use-components-in-view-classes","text":"To use components in view classes, call use_component . from spangle import use_component @api . route ( \"/comp\" ) class UseComponent : async def on_get ( self , req , resp ): my_comp = use_component ( MyComponent ) assert my_comp . value == 42 Note According to The Twelve-FactorApp , every application process should be stateless. In other words, components should contain config or database connection, but not session data. Do not use a component as a datastore.","title":"Use components in view-classes"},{"location":"component/#use-components-from-another-component","text":"A component can refer other components. class AnotherComp : async def startup ( self ): # `async` is optional. my_comp = use_component ( MyComponent ) Note There is no way to define the order of startup hooks. Do not expect that startup hooks of other components are already completed.","title":"Use components from another component"},{"location":"component/#call-use_component-out-of-api-context","text":"If you want to use components out of api context(like test environment), you can set context via api_ctx . api_ctx . set ( your_api ) component = use_component ( MyComponent )","title":"Call use_component out of api context"},{"location":"component/#use-api-instance-as-a-component","text":"You can use Api instance in view classes or components by calling use_api . class Comp : def startup ( self ): api = use_api ()","title":"Use Api instance as a component"},{"location":"error-handling/","text":"Error Handling \u00b6 spangle provides minimum error response by default. You can make custom error handler for any type of Exception . Define handler \u00b6 An error handler looks like normal view class, but has on_error method. @api . handle ( ValueError ) class Handle : # note: response body like `Response.text` are initialized. async def on_error ( self , req , resp , e : ValueError ): resp . status_code = 400 resp . text = \"Invalid request body.\" # to catch exceptions on server, set `reraise=True` . resp . reraise = True You can also use ErrorHandler instance. from spangle import Api , ErrorHandler eh = ErrorHandler () @eh . handle ( \"TypeError\" ) class Handle : ... api = Api () api . add_error_handler ( eh )","title":"Error Handling"},{"location":"error-handling/#error-handling","text":"spangle provides minimum error response by default. You can make custom error handler for any type of Exception .","title":"Error Handling"},{"location":"error-handling/#define-handler","text":"An error handler looks like normal view class, but has on_error method. @api . handle ( ValueError ) class Handle : # note: response body like `Response.text` are initialized. async def on_error ( self , req , resp , e : ValueError ): resp . status_code = 400 resp . text = \"Invalid request body.\" # to catch exceptions on server, set `reraise=True` . resp . reraise = True You can also use ErrorHandler instance. from spangle import Api , ErrorHandler eh = ErrorHandler () @eh . handle ( \"TypeError\" ) class Handle : ... api = Api () api . add_error_handler ( eh )","title":"Define handler"},{"location":"introduction/","text":"Introduction \u00b6 This document explains basic usage of spangle . Installation \u00b6 Python>=3.9 is required. pip install spangle pip install hypercorn # or your favorite ASGI server. Hello World! \u00b6 Let\u2019s create a simple app that responses JSON. # hello.py from spangle import Api api = Api () # application instance. # a view is defined as a class, and `api.route` decorates it. @api . route ( \"/\" ) class Hello : # view methods must be asynchronous. async def on_get ( self , req , resp ): resp . json . hello = \"world\" return resp # `return` is optional. hypercorn hello:api Now your first spangle app is running on your machine! Let\u2019s open 127.0.0.1:8000 in your browser. To config ASGI server, visit hypercorn\u2019s repository .","title":"Introduction"},{"location":"introduction/#introduction","text":"This document explains basic usage of spangle .","title":"Introduction"},{"location":"introduction/#installation","text":"Python>=3.9 is required. pip install spangle pip install hypercorn # or your favorite ASGI server.","title":"Installation"},{"location":"introduction/#hello-world","text":"Let\u2019s create a simple app that responses JSON. # hello.py from spangle import Api api = Api () # application instance. # a view is defined as a class, and `api.route` decorates it. @api . route ( \"/\" ) class Hello : # view methods must be asynchronous. async def on_get ( self , req , resp ): resp . json . hello = \"world\" return resp # `return` is optional. hypercorn hello:api Now your first spangle app is running on your machine! Let\u2019s open 127.0.0.1:8000 in your browser. To config ASGI server, visit hypercorn\u2019s repository .","title":"Hello World!"},{"location":"lifespan/","text":"Lifespan Event \u00b6 spangle supports lifespan events . Define events in components \u00b6 As you read this , components have lifecycle event hooks. class Life : async def startup ( self ): # called once while starting server. pass def shutdown ( self ): # called once before shutdown. pass Define events as functions \u00b6 You can also create hooks as functions. Components are available in the functions. @api . on_start async def startup (): # called AFTER component's hooks. pass @api . on_stop def shutdown (): # called BEFORE component's hooks. pass","title":"Lifespan Events"},{"location":"lifespan/#lifespan-event","text":"spangle supports lifespan events .","title":"Lifespan Event"},{"location":"lifespan/#define-events-in-components","text":"As you read this , components have lifecycle event hooks. class Life : async def startup ( self ): # called once while starting server. pass def shutdown ( self ): # called once before shutdown. pass","title":"Define events in components"},{"location":"lifespan/#define-events-as-functions","text":"You can also create hooks as functions. Components are available in the functions. @api . on_start async def startup (): # called AFTER component's hooks. pass @api . on_stop def shutdown (): # called BEFORE component's hooks. pass","title":"Define events as functions"},{"location":"methods/","text":"HTTP Methods \u00b6 on_request accepts only safe methods: GET, HEAD, OPTIONS by default. There are 2 ways to allow unsafe methods. Define on_{method} \u00b6 This example shows how to define allowed methods in a view class. You can use on_request to do common processes. @api . route ( \"/new-user\" ) class User : async def on_request ( self , req , resp ): # called before any methods. pass async def on_get ( self , req , resp ): # process only `GET` method. pass async def on_post ( self , req , resp ): # process only `POST` method. pass Set allowed_methods \u00b6 Another way is to set allowed_methods in a view class. @api . route ( \"/new-comment\" ) class Comment : allowed_methods = [ \"post\" ] async def on_request ( self , req , resp ): # able to response against `POST`! pass async def on_delete ( self , req , resp ): # `on_{method}` is also available. pass This example allows safe methods and some unsafe methods( POST, DELETE ) . Other unsafe requests like PUT will get 405 Method Not Allowed .","title":"HTTP Methods"},{"location":"methods/#http-methods","text":"on_request accepts only safe methods: GET, HEAD, OPTIONS by default. There are 2 ways to allow unsafe methods.","title":"HTTP Methods"},{"location":"methods/#define-on_method","text":"This example shows how to define allowed methods in a view class. You can use on_request to do common processes. @api . route ( \"/new-user\" ) class User : async def on_request ( self , req , resp ): # called before any methods. pass async def on_get ( self , req , resp ): # process only `GET` method. pass async def on_post ( self , req , resp ): # process only `POST` method. pass","title":"Define on_{method}"},{"location":"methods/#set-allowed_methods","text":"Another way is to set allowed_methods in a view class. @api . route ( \"/new-comment\" ) class Comment : allowed_methods = [ \"post\" ] async def on_request ( self , req , resp ): # able to response against `POST`! pass async def on_delete ( self , req , resp ): # `on_{method}` is also available. pass This example allows safe methods and some unsafe methods( POST, DELETE ) . Other unsafe requests like PUT will get 405 Method Not Allowed .","title":"Set allowed_methods"},{"location":"request-hooks/","text":"Request Hooks \u00b6 If you want to do something against all requests, use before_request and after_request . Usage \u00b6 @api . before_request class BeforeHook : async def on_request ( self , req , resp ): resp . headers [ \"X-preprocess\" ] = \"done\" @api . after_request class AfterHook : async def on_request ( self , req , resp ): resp . headers [ \"X-postprocess\" ] = \"done\"","title":"Request Hooks"},{"location":"request-hooks/#request-hooks","text":"If you want to do something against all requests, use before_request and after_request .","title":"Request Hooks"},{"location":"request-hooks/#usage","text":"@api . before_request class BeforeHook : async def on_request ( self , req , resp ): resp . headers [ \"X-preprocess\" ] = \"done\" @api . after_request class AfterHook : async def on_request ( self , req , resp ): resp . headers [ \"X-postprocess\" ] = \"done\"","title":"Usage"},{"location":"request/","text":"Request \u00b6 Request contains data sent by client. Most attributes are read-only, but you can use state to store objects like user ID. Get request headers \u00b6 Request headers are CIMultiDictProxy . @api . route ( \"/\" ) class Index : async def on_request ( self , req , resp ): headers = req . headers lower = headers . get ( \"authorization\" ) Camel = headers . get ( \"Authorization\" ) assert lower == Camel Request provides utilities to access the head of HTTP request. Method and URL \u00b6 @api . route ( \"/example\" ) class UrlExample : allowed_methods = [ \"post\" , \"put\" ] async def on_request ( self , req , resp ): assert req . method in [ \"get\" , \"post\" , \"put\" , \"head\" , \"options\" ] assert \"/example\" in req . full_url assert req . url . path . startswith ( \"/example\" ) Query string \u00b6 params is MultiDictProxy that contains parsed query strings. @api . route ( \"/search\" ) class Search : # parse `/search?q=somevalue` async def on_get ( self , req , resp ): queries = req . params value = queries . get ( \"q\" ) Cookies \u00b6 Received HTTP Cookies are stored in cookies as dict . @api . route ( \"/cookies\" ) class Cookies : async def on_get ( self , req , resp ): cookies = req . cookies for k , v in cookies . items (): print ( f \" { k } : { v } \" ) Acceptable types \u00b6 To test what types are allowed by a client, use accept . @api . route ( \"/accepts\" ) class Accepts : async def on_get ( self , req , resp ): # client's `Accept` header. assert req . headers [ \"accept\" ] == \"text/html,text/*,application/json;q=0.9\" # `text/html` is acceptable. assert req . accept ( \"text/html\" ) == ( \"text/html\" , 1.0 ) # `text/plain` is also OK, but you should return `text/html` because of wildcard. assert req . accept ( \"text/plain\" ) == ( \"text/*\" , 1.0 ) # `application/json` is allowed, but it has less priority than `text/*` . assert req . accept ( \"application/json\" ) == ( \"application/json\" , 0.9 ) # `image/png` is not allowed! assert req . accept ( \"image/png\" ) is None Receive uploaded data \u00b6 You can get request body as bytes , str , or MultiDict . Receive texts and bytes \u00b6 content is the raw body of request as bytes , and text decodes it to str . @api . route ( \"/strings\" ) class Strings : async def on_post ( self , req , resp ): # as bytes body = await req . content # as str; may raise `UnicodeDecodeError` . text = await req . text Receive form data \u00b6 In many cases, the request body has a structure. media parses the body to MultiDict . application/x-www-form-urlencoded ( form ) , multipart/form-data ( multipart ) , and application/json ( json ) are supported. @api . route ( \"/form\" ) class Form : async def on_post ( self , req , resp ): # detect the format automatically. data = await req . media () # ... or choose manually. data = await req . media ( parse_as = \"json\" ) Custom parser \u00b6 Want to parse other format like YAML ? You can use your own parser. @api . route ( \"/custom-format\" ) class Custom : async def on_post ( self , req , resp ): # pass `Callable[[Request],Awaitable[Any]]` . data = await req . media ( parser = async_func ) Limit upload size \u00b6 You can limit upload size. Api accepts application default, and you can set the limit against each request. @api . route ( \"limit-upload\" ) class Limit : async def on_post ( self , req , resp ): req . max_upload_bytes = 50 * 1024 ** 2 # raise `TooLargeRequestError` if the body is too large. data = await req . media () ... Set state \u00b6 Request.state is a flexible data container powered by addict . It is useful to share additional user data between view methods. @api . route ( \"/restricted\" ) class NeedAuth : async def on_request ( self , req , resp ): ... # process authentication req . state . user = \"user id\" async def on_get ( self , req , resp ): assert req . state . user == \"user id\" Server push \u00b6 You can use HTTP2 server push. @api . route ( \"/push\" ) class Push : async def on_get ( self , req , resp ): # `push` does nothing if not available. await req . push ( \"/statics/style.css\" ) return resp","title":"Request"},{"location":"request/#request","text":"Request contains data sent by client. Most attributes are read-only, but you can use state to store objects like user ID.","title":"Request"},{"location":"request/#get-request-headers","text":"Request headers are CIMultiDictProxy . @api . route ( \"/\" ) class Index : async def on_request ( self , req , resp ): headers = req . headers lower = headers . get ( \"authorization\" ) Camel = headers . get ( \"Authorization\" ) assert lower == Camel Request provides utilities to access the head of HTTP request.","title":"Get request headers"},{"location":"request/#method-and-url","text":"@api . route ( \"/example\" ) class UrlExample : allowed_methods = [ \"post\" , \"put\" ] async def on_request ( self , req , resp ): assert req . method in [ \"get\" , \"post\" , \"put\" , \"head\" , \"options\" ] assert \"/example\" in req . full_url assert req . url . path . startswith ( \"/example\" )","title":"Method and URL"},{"location":"request/#query-string","text":"params is MultiDictProxy that contains parsed query strings. @api . route ( \"/search\" ) class Search : # parse `/search?q=somevalue` async def on_get ( self , req , resp ): queries = req . params value = queries . get ( \"q\" )","title":"Query string"},{"location":"request/#cookies","text":"Received HTTP Cookies are stored in cookies as dict . @api . route ( \"/cookies\" ) class Cookies : async def on_get ( self , req , resp ): cookies = req . cookies for k , v in cookies . items (): print ( f \" { k } : { v } \" )","title":"Cookies"},{"location":"request/#acceptable-types","text":"To test what types are allowed by a client, use accept . @api . route ( \"/accepts\" ) class Accepts : async def on_get ( self , req , resp ): # client's `Accept` header. assert req . headers [ \"accept\" ] == \"text/html,text/*,application/json;q=0.9\" # `text/html` is acceptable. assert req . accept ( \"text/html\" ) == ( \"text/html\" , 1.0 ) # `text/plain` is also OK, but you should return `text/html` because of wildcard. assert req . accept ( \"text/plain\" ) == ( \"text/*\" , 1.0 ) # `application/json` is allowed, but it has less priority than `text/*` . assert req . accept ( \"application/json\" ) == ( \"application/json\" , 0.9 ) # `image/png` is not allowed! assert req . accept ( \"image/png\" ) is None","title":"Acceptable types"},{"location":"request/#receive-uploaded-data","text":"You can get request body as bytes , str , or MultiDict .","title":"Receive uploaded data"},{"location":"request/#receive-texts-and-bytes","text":"content is the raw body of request as bytes , and text decodes it to str . @api . route ( \"/strings\" ) class Strings : async def on_post ( self , req , resp ): # as bytes body = await req . content # as str; may raise `UnicodeDecodeError` . text = await req . text","title":"Receive texts and bytes"},{"location":"request/#receive-form-data","text":"In many cases, the request body has a structure. media parses the body to MultiDict . application/x-www-form-urlencoded ( form ) , multipart/form-data ( multipart ) , and application/json ( json ) are supported. @api . route ( \"/form\" ) class Form : async def on_post ( self , req , resp ): # detect the format automatically. data = await req . media () # ... or choose manually. data = await req . media ( parse_as = \"json\" )","title":"Receive form data"},{"location":"request/#custom-parser","text":"Want to parse other format like YAML ? You can use your own parser. @api . route ( \"/custom-format\" ) class Custom : async def on_post ( self , req , resp ): # pass `Callable[[Request],Awaitable[Any]]` . data = await req . media ( parser = async_func )","title":"Custom parser"},{"location":"request/#limit-upload-size","text":"You can limit upload size. Api accepts application default, and you can set the limit against each request. @api . route ( \"limit-upload\" ) class Limit : async def on_post ( self , req , resp ): req . max_upload_bytes = 50 * 1024 ** 2 # raise `TooLargeRequestError` if the body is too large. data = await req . media () ...","title":"Limit upload size"},{"location":"request/#set-state","text":"Request.state is a flexible data container powered by addict . It is useful to share additional user data between view methods. @api . route ( \"/restricted\" ) class NeedAuth : async def on_request ( self , req , resp ): ... # process authentication req . state . user = \"user id\" async def on_get ( self , req , resp ): assert req . state . user == \"user id\"","title":"Set state"},{"location":"request/#server-push","text":"You can use HTTP2 server push. @api . route ( \"/push\" ) class Push : async def on_get ( self , req , resp ): # `push` does nothing if not available. await req . push ( \"/statics/style.css\" ) return resp","title":"Server push"},{"location":"response/","text":"Response \u00b6 You can send data to clients by setting values to Response instance. The instance is a valid ASGI app. Set headers to Response \u00b6 Response has attributes similar to Request , but they are writable. @api . route ( \"/resp-head\" ) class Head : async def on_get ( self , req , resp ): resp . headers [ \"X-Foo\" ] = \"bar\" resp . status_code = 418 resp . cookies [ \"its\" ] = \"dict\" Send response body \u00b6 Of course, you can send a response body. Response sets Content-Type header automatically. @api . route ( \"/text\" ) class Text : async def on_get ( self , req , resp ): # Content-Type: text/plain; charset=utf-8 resp . text = \"hello!\" @api . route ( \"/bytes\" ) class Bytes : async def on_get ( self , req , resp ): # Content-Type: application/octet-stream resp . content = b \"hello!\" @api . route ( \"/json\" ) class JSON : # Content-Type: application/json async def on_get ( self , req , resp ): resp . json . hello = \"world!\" Jinja2 template \u00b6 To send html, you can use Jinja2 template. api = Api ( templates_dir = \"templates/here\" ) @api . route ( \"/template\" ) class Template : async def on_get ( self , req , resp ): # Content-Type: text/html await resp . load_template ( \"example.html\" , var = \"foobar\" ) Method chain \u00b6 Setter methods return Response itself, so you can chain these methods. @api . route ( \"/chain\" ) class Chain : async def on_get ( self , req , resp ): resp . set_status ( 200 ) . set_cookie ( \"key\" , \"value\" , secure = True ) . set_text ( \"long chain!\" ) . set_header ( \"X-somehead\" , \"value\" ) Redirect \u00b6 redirect has 2 ways: view class or URL. @api . route ( \"/redirect/internal\" ) class Redirect : async def on_get ( self , req , resp ): # redirect to the view class. resp . redirect ( view = Index ) @api . route ( \"/redirect/external\" ) class GoOuterPage : async def on_get ( self , req , resp ): # specify URL. resp . redirect ( url = \"http://www.example.com\" ) Streaming \u00b6 Using Response.streaming allows you to send data successively. async def generate (): for i in range ( 10 ): await asyncio . sleep ( 0.5 ) yield f \"count: { i } \" yield \"Completed!\" @api . route ( \"/generator\" ) class Stream : async def on_get ( self , req , resp ): resp . headers [ \"content-type\" ] = \"text/plain\" resp . streaming = generate ()","title":"Response"},{"location":"response/#response","text":"You can send data to clients by setting values to Response instance. The instance is a valid ASGI app.","title":"Response"},{"location":"response/#set-headers-to-response","text":"Response has attributes similar to Request , but they are writable. @api . route ( \"/resp-head\" ) class Head : async def on_get ( self , req , resp ): resp . headers [ \"X-Foo\" ] = \"bar\" resp . status_code = 418 resp . cookies [ \"its\" ] = \"dict\"","title":"Set headers to Response"},{"location":"response/#send-response-body","text":"Of course, you can send a response body. Response sets Content-Type header automatically. @api . route ( \"/text\" ) class Text : async def on_get ( self , req , resp ): # Content-Type: text/plain; charset=utf-8 resp . text = \"hello!\" @api . route ( \"/bytes\" ) class Bytes : async def on_get ( self , req , resp ): # Content-Type: application/octet-stream resp . content = b \"hello!\" @api . route ( \"/json\" ) class JSON : # Content-Type: application/json async def on_get ( self , req , resp ): resp . json . hello = \"world!\"","title":"Send response body"},{"location":"response/#jinja2-template","text":"To send html, you can use Jinja2 template. api = Api ( templates_dir = \"templates/here\" ) @api . route ( \"/template\" ) class Template : async def on_get ( self , req , resp ): # Content-Type: text/html await resp . load_template ( \"example.html\" , var = \"foobar\" )","title":"Jinja2 template"},{"location":"response/#method-chain","text":"Setter methods return Response itself, so you can chain these methods. @api . route ( \"/chain\" ) class Chain : async def on_get ( self , req , resp ): resp . set_status ( 200 ) . set_cookie ( \"key\" , \"value\" , secure = True ) . set_text ( \"long chain!\" ) . set_header ( \"X-somehead\" , \"value\" )","title":"Method chain"},{"location":"response/#redirect","text":"redirect has 2 ways: view class or URL. @api . route ( \"/redirect/internal\" ) class Redirect : async def on_get ( self , req , resp ): # redirect to the view class. resp . redirect ( view = Index ) @api . route ( \"/redirect/external\" ) class GoOuterPage : async def on_get ( self , req , resp ): # specify URL. resp . redirect ( url = \"http://www.example.com\" )","title":"Redirect"},{"location":"response/#streaming","text":"Using Response.streaming allows you to send data successively. async def generate (): for i in range ( 10 ): await asyncio . sleep ( 0.5 ) yield f \"count: { i } \" yield \"Completed!\" @api . route ( \"/generator\" ) class Stream : async def on_get ( self , req , resp ): resp . headers [ \"content-type\" ] = \"text/plain\" resp . streaming = generate ()","title":"Streaming"},{"location":"routing/","text":"Routing \u00b6 spangle provides simple and flexible routing powered by parse . Static routing \u00b6 # routing.py from spangle import Api api = Api () @api . route ( \"/path/to/page\" ) class StaticRoute : async def on_request ( self , req , resp ): pass Dynamic routing \u00b6 You can get values from URL by using f-string style routing. # routing.py @api . route ( \"/path/to/ {name} \" ) class DynamicRoute ( object ): async def on_request ( self , req , resp , name : str ): # `spangle` tries to get a view from static routes first. assert name != \"page\" @api . route ( \"/use/ {multiple} / {allowed} \" ) class Multiple : async def on_request ( self , req , resp , ** kw ): assert \"multiple\" in kw assert \"allowed\" in kw Convert values \u00b6 View methods accept URL arguments as str by default. You can change this behavior to set converters. # routing.py # `default`, `int` and `float` are built-in converters. # `str` is an alias of `default`. @api . route ( \"/use/{dynamic:int}\" ) class IntArg : async def on_request ( self , req , resp , dynamic ): assert isinstance ( dynamic , int ) # `default` match does not contain slash(`/`). # `rest_string` converter matches any characters including slash. @api . route ( \"/{for_spa:rest_string}\" ) @api . route ( \"/\" ) class SpaView : async def on_get ( self , req , resp , ** kw ): ... # You can define custom converters as `Dict[str,Callable]` . def month ( v : str ) -> int : m = int ( v ) if not ( 1 <= m <= 12 ): raise ValueError @api . route ( \"/articles-in-{m:month}\" , converters = { \"month\" : month }) class CustomConverter : async def on_request ( self , req , resp , m ): assert 1 <= m <= 12 # You can use regular expression to set pattern to `converter.pattern` . def regex ( x ): return x regex . pattern = r \"[A-Za-z]+(/[A-Za-z]+)+\" @api . route ( \"/accept/custom-pattern/{path:regex}\" , converters = { \"regex\" : regex }) class SlashRequired : async def on_request ( self , req , resp , path ): assert \"/\" in path See parse for more details. Routing Strategies \u00b6 spangle has 4 strategies about trailing slash. \"no_slash\" (default): always redirect from /route/ to /route with 308 PERMANENT_REDIRECT . \"slash\" : always redirect from /route to /route/ with 308 PERMANENT_REDIRECT . \"strict\" : distinct /route from /route/ . \"clone\" : return same view between /route and /route/ . To change default strategy, create Api instance with an argument like Api(routing=\"clone\") . If you need to set different strategy against views, use route(view, routing=\"{strategy}\") . @api . route ( \"/flexible/rules\" , routing = \"clone\" ) class Strategy : ...","title":"Routing"},{"location":"routing/#routing","text":"spangle provides simple and flexible routing powered by parse .","title":"Routing"},{"location":"routing/#static-routing","text":"# routing.py from spangle import Api api = Api () @api . route ( \"/path/to/page\" ) class StaticRoute : async def on_request ( self , req , resp ): pass","title":"Static routing"},{"location":"routing/#dynamic-routing","text":"You can get values from URL by using f-string style routing. # routing.py @api . route ( \"/path/to/ {name} \" ) class DynamicRoute ( object ): async def on_request ( self , req , resp , name : str ): # `spangle` tries to get a view from static routes first. assert name != \"page\" @api . route ( \"/use/ {multiple} / {allowed} \" ) class Multiple : async def on_request ( self , req , resp , ** kw ): assert \"multiple\" in kw assert \"allowed\" in kw","title":"Dynamic routing"},{"location":"routing/#convert-values","text":"View methods accept URL arguments as str by default. You can change this behavior to set converters. # routing.py # `default`, `int` and `float` are built-in converters. # `str` is an alias of `default`. @api . route ( \"/use/{dynamic:int}\" ) class IntArg : async def on_request ( self , req , resp , dynamic ): assert isinstance ( dynamic , int ) # `default` match does not contain slash(`/`). # `rest_string` converter matches any characters including slash. @api . route ( \"/{for_spa:rest_string}\" ) @api . route ( \"/\" ) class SpaView : async def on_get ( self , req , resp , ** kw ): ... # You can define custom converters as `Dict[str,Callable]` . def month ( v : str ) -> int : m = int ( v ) if not ( 1 <= m <= 12 ): raise ValueError @api . route ( \"/articles-in-{m:month}\" , converters = { \"month\" : month }) class CustomConverter : async def on_request ( self , req , resp , m ): assert 1 <= m <= 12 # You can use regular expression to set pattern to `converter.pattern` . def regex ( x ): return x regex . pattern = r \"[A-Za-z]+(/[A-Za-z]+)+\" @api . route ( \"/accept/custom-pattern/{path:regex}\" , converters = { \"regex\" : regex }) class SlashRequired : async def on_request ( self , req , resp , path ): assert \"/\" in path See parse for more details.","title":"Convert values"},{"location":"routing/#routing-strategies","text":"spangle has 4 strategies about trailing slash. \"no_slash\" (default): always redirect from /route/ to /route with 308 PERMANENT_REDIRECT . \"slash\" : always redirect from /route to /route/ with 308 PERMANENT_REDIRECT . \"strict\" : distinct /route from /route/ . \"clone\" : return same view between /route and /route/ . To change default strategy, create Api instance with an argument like Api(routing=\"clone\") . If you need to set different strategy against views, use route(view, routing=\"{strategy}\") . @api . route ( \"/flexible/rules\" , routing = \"clone\" ) class Strategy : ...","title":"Routing Strategies"},{"location":"statics/","text":"Static Files \u00b6 You should serve static files from other servers like nginx in production, but spangle provides static file response for developing. Usage \u00b6 # map requests `/static/files/*` to `path/to/dir/*` . api = Api ( static_dir = \"path/to/dir\" , static_root = \"/static/files\" ) If you want to disable static files serving, set static_dir=None . favicon.ico \u00b6 To serve a file at {static_dir}/images/favicon.ico against requests to /favicon , pass the argument like Api(favicon=\"images/favicon.ico\") .","title":"Static Files"},{"location":"statics/#static-files","text":"You should serve static files from other servers like nginx in production, but spangle provides static file response for developing.","title":"Static Files"},{"location":"statics/#usage","text":"# map requests `/static/files/*` to `path/to/dir/*` . api = Api ( static_dir = \"path/to/dir\" , static_root = \"/static/files\" ) If you want to disable static files serving, set static_dir=None .","title":"Usage"},{"location":"statics/#faviconico","text":"To serve a file at {static_dir}/images/favicon.ico against requests to /favicon , pass the argument like Api(favicon=\"images/favicon.ico\") .","title":"favicon.ico"},{"location":"test-client/","text":"Test Client \u00b6 Api.client is useful for unittest. The client is based on httpx . Usage \u00b6 Using Api.client allows you to run your api without starting an actual server. Lifespan events are also available. api = Api () @api . route ( \"/testing/ {value} \" ) class TestView : async def on_get ( self , req , resp , value ): resp . status_code = 418 resp . text = value @api . on_start def start ( comps ): print ( \"App is starting...\" ) # `async with` statement emulates lifespan events. async with api . client () as client : # console shows `App is starting...` . path = api . url_for ( TestView , { \"value\" : \"spam\" }) response = await client . get ( path ) assert response . status_code = 418 assert response . text = \"spam\" # shutdown hooks are called here.","title":"Test Client"},{"location":"test-client/#test-client","text":"Api.client is useful for unittest. The client is based on httpx .","title":"Test Client"},{"location":"test-client/#usage","text":"Using Api.client allows you to run your api without starting an actual server. Lifespan events are also available. api = Api () @api . route ( \"/testing/ {value} \" ) class TestView : async def on_get ( self , req , resp , value ): resp . status_code = 418 resp . text = value @api . on_start def start ( comps ): print ( \"App is starting...\" ) # `async with` statement emulates lifespan events. async with api . client () as client : # console shows `App is starting...` . path = api . url_for ( TestView , { \"value\" : \"spam\" }) response = await client . get ( path ) assert response . status_code = 418 assert response . text = \"spam\" # shutdown hooks are called here.","title":"Usage"},{"location":"advanced/","text":"Advanced features \u00b6 spangle has more features to develop modern web. Feature list \u00b6 Application Blueprint WebSocket Use Decorator ASGI Middleware Mount Other ASGI App Default Routing CLI Tools","title":"Advanced features"},{"location":"advanced/#advanced-features","text":"spangle has more features to develop modern web.","title":"Advanced features"},{"location":"advanced/#feature-list","text":"Application Blueprint WebSocket Use Decorator ASGI Middleware Mount Other ASGI App Default Routing CLI Tools","title":"Feature list"},{"location":"advanced/SUMMARY/","text":"Application Blueprint WebSocket Use Decorator ASGI Middleware Mount Other ASGI App Default Routing CLI Tools","title":"SUMMARY"},{"location":"advanced/blueprint/","text":"Application Blueprint \u00b6 Want to split an application? Or put views together under the same route? Use Blueprint . Usage \u00b6 Blueprint has similar methods to Api , so you can use Blueprint to define views, hooks, and handlers. from spangle import Api , Blueprint bp = Blueprint () @bp . route ( \"/\" ) class Images : pass @bp . route ( \"/ {tag} \" ) class Tag : pass @bp . on_start async def start_bp (): pass api = Api () api . add_blueprint ( \"/images\" , bp ) Note Blueprint instance is not an ASGI application. Nest blueprints \u00b6 A Blueprint instance can nest another one. child_bp = Blueprint () parent_bp = Blueprint () @child_bp . route ( \"/child\" ) class Child : pass parent_bp . add_blueprint ( \"/and\" , child_bp ) api . add_blueprint ( \"/parent\" , parent_bp )","title":"Application Blueprint"},{"location":"advanced/blueprint/#application-blueprint","text":"Want to split an application? Or put views together under the same route? Use Blueprint .","title":"Application Blueprint"},{"location":"advanced/blueprint/#usage","text":"Blueprint has similar methods to Api , so you can use Blueprint to define views, hooks, and handlers. from spangle import Api , Blueprint bp = Blueprint () @bp . route ( \"/\" ) class Images : pass @bp . route ( \"/ {tag} \" ) class Tag : pass @bp . on_start async def start_bp (): pass api = Api () api . add_blueprint ( \"/images\" , bp ) Note Blueprint instance is not an ASGI application.","title":"Usage"},{"location":"advanced/blueprint/#nest-blueprints","text":"A Blueprint instance can nest another one. child_bp = Blueprint () parent_bp = Blueprint () @child_bp . route ( \"/child\" ) class Child : pass parent_bp . add_blueprint ( \"/and\" , child_bp ) api . add_blueprint ( \"/parent\" , parent_bp )","title":"Nest blueprints"},{"location":"advanced/cli-tools/","text":"CLI Tools \u00b6 spangle provides some tools for development. spangle urls-ts \u00b6 This command generates a small script to map view names to paths like Api.url_for . Parameters of dynamic paths are supported. Usage \u00b6 spangle urls-ts path.to.app:instance > urls.ts Generated file looks like this: // urls.ts type ViewName = \"path.to.app.Index\" | \"path.to.app.Store\" | \"path.to.app.Get\" ; type Params = { \"path.to.app.Index\" : {}; \"path.to.app.Store\" : {}; \"path.to.app.Get\" : { key : string ; }; }; const tag = ( strings : TemplateStringsArray , ... keys : string []) => { const call = ( p : { [ key : string ] : string }) => { if ( keys . length === 0 ) { return strings . join (); } const parsed = keys . map (( x ) => p [ x ]) . filter (( x ) => typeof x !== \"undefined\" ); if ( Object . keys ( parsed ). length === 0 ) { return null ; } parsed . push ( \"\" ); return strings . map (( x , index ) => x + parsed [ index ]). join ( \"\" ); }; return call ; }; const taggedViews = { \"path.to.app.Index\" : tag `/` , \"path.to.app.Store\" : tag `/store` , \"path.to.app.Get\" : tag `/dynamic/ ${ \"key\" } ` , }; export const urlFor = < T extends ViewName > ( name : T , params : Params [ T ] ) : string => { const tagged = taggedViews [ name ]; return tagged ( params ) as T ; }; To get a path, use a name of the view class instead of the class itself.","title":"CLI Tools"},{"location":"advanced/cli-tools/#cli-tools","text":"spangle provides some tools for development.","title":"CLI Tools"},{"location":"advanced/cli-tools/#spangle-urls-ts","text":"This command generates a small script to map view names to paths like Api.url_for . Parameters of dynamic paths are supported.","title":"spangle urls-ts"},{"location":"advanced/cli-tools/#usage","text":"spangle urls-ts path.to.app:instance > urls.ts Generated file looks like this: // urls.ts type ViewName = \"path.to.app.Index\" | \"path.to.app.Store\" | \"path.to.app.Get\" ; type Params = { \"path.to.app.Index\" : {}; \"path.to.app.Store\" : {}; \"path.to.app.Get\" : { key : string ; }; }; const tag = ( strings : TemplateStringsArray , ... keys : string []) => { const call = ( p : { [ key : string ] : string }) => { if ( keys . length === 0 ) { return strings . join (); } const parsed = keys . map (( x ) => p [ x ]) . filter (( x ) => typeof x !== \"undefined\" ); if ( Object . keys ( parsed ). length === 0 ) { return null ; } parsed . push ( \"\" ); return strings . map (( x , index ) => x + parsed [ index ]). join ( \"\" ); }; return call ; }; const taggedViews = { \"path.to.app.Index\" : tag `/` , \"path.to.app.Store\" : tag `/store` , \"path.to.app.Get\" : tag `/dynamic/ ${ \"key\" } ` , }; export const urlFor = < T extends ViewName > ( name : T , params : Params [ T ] ) : string => { const tagged = taggedViews [ name ]; return tagged ( params ) as T ; }; To get a path, use a name of the view class instead of the class itself.","title":"Usage"},{"location":"advanced/decorator/","text":"Use Decorator \u00b6 To append common routines to views, you can make your own decorator. Simple decorator example \u00b6 This is an example to implement your login_required decorator. def login_required ( f ): async def inner ( view , req : Request , resp : Response , ** params ): auth = use_component ( AuthComp ) token = req . headers [ \"authorization\" ] user = await auth . get_user ( token ) if not user : raise AuthError ( \"Need to login.\" ) req . state . user = user return await f ( view , req , resp , ** params ) return inner # usage @api . route ( \"/secrets\" ) class Secret : @login_required async def on_request ( self , req , resp ): assert req . state . user async def on_post ( self , req , resp ): # login required for all methods. assert req . state . user","title":"Use Decorator"},{"location":"advanced/decorator/#use-decorator","text":"To append common routines to views, you can make your own decorator.","title":"Use Decorator"},{"location":"advanced/decorator/#simple-decorator-example","text":"This is an example to implement your login_required decorator. def login_required ( f ): async def inner ( view , req : Request , resp : Response , ** params ): auth = use_component ( AuthComp ) token = req . headers [ \"authorization\" ] user = await auth . get_user ( token ) if not user : raise AuthError ( \"Need to login.\" ) req . state . user = user return await f ( view , req , resp , ** params ) return inner # usage @api . route ( \"/secrets\" ) class Secret : @login_required async def on_request ( self , req , resp ): assert req . state . user async def on_post ( self , req , resp ): # login required for all methods. assert req . state . user","title":"Simple decorator example"},{"location":"advanced/default-route/","text":"Default Routing for Single Page Application \u00b6 To create single page application, default_route and multiple routing help you. Default route \u00b6 api = Api ( default_route = \"/default\" ) @api . route ( \"/default\" ) class Default : pass @api . route ( \"/spam\" ) class Spam : pass In this example, a request to /spam gets a response from Spam , and the other requests include /default get responses from Default , so any users get not 404 responses. Multiple routing for allowed patterns \u00b6 A soft 404 is a bad practice. Routing allowed patterns to a view removes worry of the problem. api = Api () @api . route ( \"/need/{converter:func}\" , converters = { \"func\" : lambda x : x * 2 } ) @api . route ( \"/api/more/longer/path\" ) @api . route ( \"/api/ {foo} \" ) @api . route ( \"/\" ) class Index : async def on_get ( self , req , resp , ** kw ): # `kw` may contain parsed path params. pass api returns Index to matched requests, and others get 404 .","title":"Default Routing"},{"location":"advanced/default-route/#default-routing-for-single-page-application","text":"To create single page application, default_route and multiple routing help you.","title":"Default Routing for Single Page Application"},{"location":"advanced/default-route/#default-route","text":"api = Api ( default_route = \"/default\" ) @api . route ( \"/default\" ) class Default : pass @api . route ( \"/spam\" ) class Spam : pass In this example, a request to /spam gets a response from Spam , and the other requests include /default get responses from Default , so any users get not 404 responses.","title":"Default route"},{"location":"advanced/default-route/#multiple-routing-for-allowed-patterns","text":"A soft 404 is a bad practice. Routing allowed patterns to a view removes worry of the problem. api = Api () @api . route ( \"/need/{converter:func}\" , converters = { \"func\" : lambda x : x * 2 } ) @api . route ( \"/api/more/longer/path\" ) @api . route ( \"/api/ {foo} \" ) @api . route ( \"/\" ) class Index : async def on_get ( self , req , resp , ** kw ): # `kw` may contain parsed path params. pass api returns Index to matched requests, and others get 404 .","title":"Multiple routing for allowed patterns"},{"location":"advanced/middleware/","text":"ASGI Middleware \u00b6 spangle uses only one middleware: starlette.ServerErrorMiddleware . You can use other ASGI middlewares with spangle . Append middlewares \u00b6 To use middlewares, call Api.add_middleware with callable and its config. from spangle import Api from starlette.middleware.trustedhost import TrustedHostMiddleware api = Api () api . add_middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) Middlewares order \u00b6 When ASGI middlewares are added like this: middlewares = [ m1 , m2 , m3 ] for m in middlewares : api . add_middleware ( m ) \u2026 then, the application looks like this: call m3(scope, receive, send): *m3 preprocess* call m2(scope, receive, send): *m2 preprocess* call m1(scope, receive, send): *m1 preprocess* call api(scope, receive, send) *m1 postprosess* *m2 postprosess* *m3 postprosess* Be careful in order of middlewares.","title":"ASGI Middleware"},{"location":"advanced/middleware/#asgi-middleware","text":"spangle uses only one middleware: starlette.ServerErrorMiddleware . You can use other ASGI middlewares with spangle .","title":"ASGI Middleware"},{"location":"advanced/middleware/#append-middlewares","text":"To use middlewares, call Api.add_middleware with callable and its config. from spangle import Api from starlette.middleware.trustedhost import TrustedHostMiddleware api = Api () api . add_middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ])","title":"Append middlewares"},{"location":"advanced/middleware/#middlewares-order","text":"When ASGI middlewares are added like this: middlewares = [ m1 , m2 , m3 ] for m in middlewares : api . add_middleware ( m ) \u2026 then, the application looks like this: call m3(scope, receive, send): *m3 preprocess* call m2(scope, receive, send): *m2 preprocess* call m1(scope, receive, send): *m1 preprocess* call api(scope, receive, send) *m1 postprosess* *m2 postprosess* *m3 postprosess* Be careful in order of middlewares.","title":"Middlewares order"},{"location":"advanced/mount/","text":"Mount Other ASGI App \u00b6 If you want to use existing ASGI app in your app, you can nest the app in yours by using Api.mount . ariadne example \u00b6 ariadne is a graphql engine written in python that has asynchronous resolvers and query execution. It also works as an ASGI app. from spangle import Api from ariadne import make_executable_schema from ariadne.asgi import GraphQL # your graphql resolvers. from mygraphql import type_defs , resolvers schema = make_executable_schema ( type_defs , resolvers ) gqlapp = GraphQL ( schema ) api = Api () api . mount ( \"/graphql\" , gqlapp ) Use Request , Response , and components in mounted app \u00b6 You can use some spangle objects in a mounted app via scope . The scope looks like this: scope = { ... \"extensions\" : { \"spangle\" : { # for HTTP connection. \"req\" : models . Request , \"resp\" : models . Response , # for WebSocket connection. \"conn\" : models . Connection , } } } To use some components, just call use_component .","title":"Mount Other ASGI App"},{"location":"advanced/mount/#mount-other-asgi-app","text":"If you want to use existing ASGI app in your app, you can nest the app in yours by using Api.mount .","title":"Mount Other ASGI App"},{"location":"advanced/mount/#ariadne-example","text":"ariadne is a graphql engine written in python that has asynchronous resolvers and query execution. It also works as an ASGI app. from spangle import Api from ariadne import make_executable_schema from ariadne.asgi import GraphQL # your graphql resolvers. from mygraphql import type_defs , resolvers schema = make_executable_schema ( type_defs , resolvers ) gqlapp = GraphQL ( schema ) api = Api () api . mount ( \"/graphql\" , gqlapp )","title":"ariadne example"},{"location":"advanced/mount/#use-request-response-and-components-in-mounted-app","text":"You can use some spangle objects in a mounted app via scope . The scope looks like this: scope = { ... \"extensions\" : { \"spangle\" : { # for HTTP connection. \"req\" : models . Request , \"resp\" : models . Response , # for WebSocket connection. \"conn\" : models . Connection , } } } To use some components, just call use_component .","title":"Use Request , Response , and components in mounted app"},{"location":"advanced/websocket/","text":"WebSocket \u00b6 spangle supports WebSocket connection. WebSocket view class \u00b6 You can define a WebSocket endpoint the same as HTTP endpoint, but the name is on_ws . @api . route ( \"/websocket/ {name} \" , routing = \"clone\" ) class WebSocket : async def on_ws ( self , conn , name : str ): await conn . accept () await conn . send ( f \"hello, { name } !\" ) while True : data = await conn . receive ( str ) if data == \"end\" : break await conn . send ( f \"you said ` { data } ` .\" ) await conn . send ( \"bye.\" ) await conn . close ( 1000 ) Note HTTP Upgrade Request is processed in an ASGI server, so you don\u2019t need to send 101 Switching Protocols manually. Error handling for WebSocket \u00b6 You can process WebSocket errors with ErrorHandler . @api . handle ( TypeError ) class Handler : async def on_ws_error ( self , conn , e : TypeError ): await conn . send ( \"Invalid data.\" ) await conn . close ( 1007 ) Before and After WebSocket connection \u00b6 Hooks before/after WebSocket connection. @api . before_requesst class CalledBefore : async def on_ws ( self , conn ): conn . state . value = 42 @api . after_requesst class CalledAfter : async def on_ws ( self , conn ): conn . state . done = True Note that after_request hooks are called after connection closing. WebSocket Testing \u00b6 WebSocket test cllient is also available. async with api . client () as client : async with client . ws_connect ( \"/websocket/spam\" ) as connection : data = await connection . receive ( str ) assert data == \"hello, spam!\" await connection . send ( \"async!\" ) data = connection . receive ( str ) assert data == \"you said `async!` .\"","title":"WebSocket"},{"location":"advanced/websocket/#websocket","text":"spangle supports WebSocket connection.","title":"WebSocket"},{"location":"advanced/websocket/#websocket-view-class","text":"You can define a WebSocket endpoint the same as HTTP endpoint, but the name is on_ws . @api . route ( \"/websocket/ {name} \" , routing = \"clone\" ) class WebSocket : async def on_ws ( self , conn , name : str ): await conn . accept () await conn . send ( f \"hello, { name } !\" ) while True : data = await conn . receive ( str ) if data == \"end\" : break await conn . send ( f \"you said ` { data } ` .\" ) await conn . send ( \"bye.\" ) await conn . close ( 1000 ) Note HTTP Upgrade Request is processed in an ASGI server, so you don\u2019t need to send 101 Switching Protocols manually.","title":"WebSocket view class"},{"location":"advanced/websocket/#error-handling-for-websocket","text":"You can process WebSocket errors with ErrorHandler . @api . handle ( TypeError ) class Handler : async def on_ws_error ( self , conn , e : TypeError ): await conn . send ( \"Invalid data.\" ) await conn . close ( 1007 )","title":"Error handling for WebSocket"},{"location":"advanced/websocket/#before-and-after-websocket-connection","text":"Hooks before/after WebSocket connection. @api . before_requesst class CalledBefore : async def on_ws ( self , conn ): conn . state . value = 42 @api . after_requesst class CalledAfter : async def on_ws ( self , conn ): conn . state . done = True Note that after_request hooks are called after connection closing.","title":"Before and After WebSocket connection"},{"location":"advanced/websocket/#websocket-testing","text":"WebSocket test cllient is also available. async with api . client () as client : async with client . ws_connect ( \"/websocket/spam\" ) as connection : data = await connection . receive ( str ) assert data == \"hello, spam!\" await connection . send ( \"async!\" ) data = connection . receive ( str ) assert data == \"you said `async!` .\"","title":"WebSocket Testing"},{"location":"api/","text":"Module spangle \u00b6 spangle - A small and flexible ASGI application framework for modern web. Submodules \u00b6 spangle.api spangle.blueprint spangle.cli spangle.component spangle.error_handler spangle.exceptions spangle.handler_protocols spangle.models spangle.parser spangle.testing spangle.types","title":"spangle"},{"location":"api/#module-spangle","text":"spangle - A small and flexible ASGI application framework for modern web.","title":"Module spangle"},{"location":"api/#submodules","text":"spangle.api spangle.blueprint spangle.cli spangle.component spangle.error_handler spangle.exceptions spangle.handler_protocols spangle.models spangle.parser spangle.testing spangle.types","title":"Submodules"},{"location":"api/api-py/","text":"Module spangle.api \u00b6 Main Api class. Classes \u00b6 Api \u00b6 class Api ( self , debug : bool = False , static_root : Optional [ str ] = \"/static\" , static_dir : Optional [ str ] = \"static\" , favicon : Optional [ str ] = None , auto_escape : bool = True , templates_dir : Optional [ str ] = \"templates\" , routing : RoutingStrategy = \"no_slash\" , default_route : Optional [ str ] = None , middleware : Optional [ list [ tuple [ Callable , dict ]]] = None , components : Optional [ list [ type [ AnyComponentProtocol ]]] = None , max_upload_bytes : int = 10 * ( 2 ** 10 ) ** 2 ,) The main application class. Attributes router ( spangle.blueprint.Router ): Manage URLs and views. mounted_app ( dict[str, ASGIApp] ): ASGI apps mounted under Api . error_handlers ( dict[type[Exception], type[ErrorHandlerProtocol]] ): Called when Exception is raised. request_hooks ( dict[str, list[type]] ): Called against every request. lifespan_handlers ( spangle.types.LifespanHandlers ): Registered lifespan hooks. favicon ( Optional[str] ): Place of favicon.ico in static_dir . debug ( bool ): Server running mode. routing ( spangle.types.RoutingStrategy ): Routing strategy about trailing slash. templates_dir ( str ): Path to Jinja2 templates. max_upload_bytes ( int ): Allowed user uploads size. Args debug ( bool ): If set True , the app will run in dev-mode. static_root ( Optional[str] ): The root path that clients access statics. If you want to disable static_file , set None . static_dir ( Optional[str] ): The root directory that contains static files. If you want to disable static_file , set None . favicon ( Optional[str] ): When a client requests \"/favicon.ico\" , Api responses \"static_dir/{given_file}\" . Optional; defaults to None . auto_escape ( bool ): If set True (default), Jinja2 renders templates with escaping. templates_dir ( Optional[str] ): The root directory that contains Jinja2 templates. If you want to disable rendering templates, set None . routing ( spangle.types.RoutingStrategy ): Set routing strategy. Default: \"no_slash\" default_route ( Optional[str] ): Use the view bound with given path instead of returning 404. middleware ( Optional[list[tuple[Callable, dict]]] ): Your custom list of asgi middleware. Add later, called faster. components ( Optional[list[type[AnyComponentProtocol]]] ): list of class used in your views. max_upload_bytes ( int ): Limit of user upload size. Defaults to 10MB. Methods \u00b6 add_blueprint def add_blueprint ( self , path : str , blueprint : Blueprint ) -> None Mount a blueprint under the given path, and register error/event handlers. Args path ( str ): Prefix for the blueprint. blueprint ( spangle.blueprint.Blueprint ): A spangle.blueprint.Blueprint instance to mount. add_error_handler def add_error_handler ( self , eh : ErrorHandler ) -> None Register spangle.error_handler.ErrorHandler to the api. Args eh ( spangle.error_handler.ErrorHandler ): An spangle.error_handler.ErrorHandler instance. add_lifespan_handler def add_lifespan_handler ( self , event_type : Literal [ \"startup\" , \"shutdown\" ], handler : LifespanFunction , ) -> None Register functions called at startup/shutdown. Args event_type ( \"startup\" | \"shutdown\" ): The event type. handler ( spangle.api.LifespanFunction ): The function called at the event. add_middleware def add_middleware ( self , middleware : Callable [ ... , ASGIApp ], ** config ) -> None ASGI middleware. Add faster, called later. Args middleware ( Callable ): An ASGI middleware. **config : params for the middleware. after_request def after_request ( self , handler : type [ RequestHandlerProtocol ] ) -> type [ RequestHandlerProtocol ] Decorator to add a class called after each request processed. before_request def before_request ( self , handler : type [ RequestHandlerProtocol ] ) -> type [ RequestHandlerProtocol ] Decorator to add a class called before each request processed. client def client ( self , timeout : Optional [ float ] = 1 ) -> AsyncHttpTestClient Asynchronous test client. To test lifespan events, use async with statement. Args timeout ( Optional[float] ): Seconds waiting for startup/shutdown/requests. to disable, set None . Default: 1 . Returns spangle.testing.AsyncHttpTestClient handle def handle ( self , e : type [ Exception ] ) -> Callable [[ type [ ErrorHandlerProtocol ]], type [ ErrorHandlerProtocol ]] Bind Exception to the decorated view. Args e ( type[Exception] ): Subclass of Exception you want to handle. mount def mount ( self , path : str , app : ASGIApp ) -> None Mount any ASGI3 app under the path . Args path ( str ): The root of given app. app ( ASGIApp ): ASGI app to mount. on_start def on_start ( self , f : LifespanFunction ) -> LifespanFunction Decorator for startup events. on_stop def on_stop ( self , f : LifespanFunction ) -> LifespanFunction Decorator for shutdown events. register_component def register_component ( self , component : type [ AnyComponentProtocol ] ) -> type [ AnyComponentProtocol ] Register component to api instance. Args component ( type[AnyComponentProtocol] ): Component class. Returns Component class itself. route def route ( self , path : str , * , converters : Optional [ Converters ] = None , routing : Optional [ RoutingStrategy ] = None , ) -> Callable [[ type [ AnyRequestHandlerProtocol ]], type [ AnyRequestHandlerProtocol ]] Mount the decorated view to the given path directly. Args path ( str ): The location for the view. converters ( Optional[Converters] ): Params converters for dynamic routing. routing ( Optional[RoutingStrategy] ): Routing strategy. url_for def url_for ( self , view : type [ AnyRequestHandlerProtocol ], params : Optional [ dict [ str , Any ]] = None , ) -> str Map view-class to path formatted with given params. Args view ( type[AnyRequestHandlerProtocol] ): The view-class for the url. params ( Optional[dict[str, Any]] ): Used to format dynamic path.","title":"spangle.api"},{"location":"api/api-py/#module-spangleapi","text":"Main Api class.","title":"Module spangle.api"},{"location":"api/api-py/#classes","text":"","title":"Classes"},{"location":"api/api-py/#Api","text":"class Api ( self , debug : bool = False , static_root : Optional [ str ] = \"/static\" , static_dir : Optional [ str ] = \"static\" , favicon : Optional [ str ] = None , auto_escape : bool = True , templates_dir : Optional [ str ] = \"templates\" , routing : RoutingStrategy = \"no_slash\" , default_route : Optional [ str ] = None , middleware : Optional [ list [ tuple [ Callable , dict ]]] = None , components : Optional [ list [ type [ AnyComponentProtocol ]]] = None , max_upload_bytes : int = 10 * ( 2 ** 10 ) ** 2 ,) The main application class. Attributes router ( spangle.blueprint.Router ): Manage URLs and views. mounted_app ( dict[str, ASGIApp] ): ASGI apps mounted under Api . error_handlers ( dict[type[Exception], type[ErrorHandlerProtocol]] ): Called when Exception is raised. request_hooks ( dict[str, list[type]] ): Called against every request. lifespan_handlers ( spangle.types.LifespanHandlers ): Registered lifespan hooks. favicon ( Optional[str] ): Place of favicon.ico in static_dir . debug ( bool ): Server running mode. routing ( spangle.types.RoutingStrategy ): Routing strategy about trailing slash. templates_dir ( str ): Path to Jinja2 templates. max_upload_bytes ( int ): Allowed user uploads size. Args debug ( bool ): If set True , the app will run in dev-mode. static_root ( Optional[str] ): The root path that clients access statics. If you want to disable static_file , set None . static_dir ( Optional[str] ): The root directory that contains static files. If you want to disable static_file , set None . favicon ( Optional[str] ): When a client requests \"/favicon.ico\" , Api responses \"static_dir/{given_file}\" . Optional; defaults to None . auto_escape ( bool ): If set True (default), Jinja2 renders templates with escaping. templates_dir ( Optional[str] ): The root directory that contains Jinja2 templates. If you want to disable rendering templates, set None . routing ( spangle.types.RoutingStrategy ): Set routing strategy. Default: \"no_slash\" default_route ( Optional[str] ): Use the view bound with given path instead of returning 404. middleware ( Optional[list[tuple[Callable, dict]]] ): Your custom list of asgi middleware. Add later, called faster. components ( Optional[list[type[AnyComponentProtocol]]] ): list of class used in your views. max_upload_bytes ( int ): Limit of user upload size. Defaults to 10MB.","title":"Api"},{"location":"api/api-py/#Api-methods","text":"add_blueprint def add_blueprint ( self , path : str , blueprint : Blueprint ) -> None Mount a blueprint under the given path, and register error/event handlers. Args path ( str ): Prefix for the blueprint. blueprint ( spangle.blueprint.Blueprint ): A spangle.blueprint.Blueprint instance to mount. add_error_handler def add_error_handler ( self , eh : ErrorHandler ) -> None Register spangle.error_handler.ErrorHandler to the api. Args eh ( spangle.error_handler.ErrorHandler ): An spangle.error_handler.ErrorHandler instance. add_lifespan_handler def add_lifespan_handler ( self , event_type : Literal [ \"startup\" , \"shutdown\" ], handler : LifespanFunction , ) -> None Register functions called at startup/shutdown. Args event_type ( \"startup\" | \"shutdown\" ): The event type. handler ( spangle.api.LifespanFunction ): The function called at the event. add_middleware def add_middleware ( self , middleware : Callable [ ... , ASGIApp ], ** config ) -> None ASGI middleware. Add faster, called later. Args middleware ( Callable ): An ASGI middleware. **config : params for the middleware. after_request def after_request ( self , handler : type [ RequestHandlerProtocol ] ) -> type [ RequestHandlerProtocol ] Decorator to add a class called after each request processed. before_request def before_request ( self , handler : type [ RequestHandlerProtocol ] ) -> type [ RequestHandlerProtocol ] Decorator to add a class called before each request processed. client def client ( self , timeout : Optional [ float ] = 1 ) -> AsyncHttpTestClient Asynchronous test client. To test lifespan events, use async with statement. Args timeout ( Optional[float] ): Seconds waiting for startup/shutdown/requests. to disable, set None . Default: 1 . Returns spangle.testing.AsyncHttpTestClient handle def handle ( self , e : type [ Exception ] ) -> Callable [[ type [ ErrorHandlerProtocol ]], type [ ErrorHandlerProtocol ]] Bind Exception to the decorated view. Args e ( type[Exception] ): Subclass of Exception you want to handle. mount def mount ( self , path : str , app : ASGIApp ) -> None Mount any ASGI3 app under the path . Args path ( str ): The root of given app. app ( ASGIApp ): ASGI app to mount. on_start def on_start ( self , f : LifespanFunction ) -> LifespanFunction Decorator for startup events. on_stop def on_stop ( self , f : LifespanFunction ) -> LifespanFunction Decorator for shutdown events. register_component def register_component ( self , component : type [ AnyComponentProtocol ] ) -> type [ AnyComponentProtocol ] Register component to api instance. Args component ( type[AnyComponentProtocol] ): Component class. Returns Component class itself. route def route ( self , path : str , * , converters : Optional [ Converters ] = None , routing : Optional [ RoutingStrategy ] = None , ) -> Callable [[ type [ AnyRequestHandlerProtocol ]], type [ AnyRequestHandlerProtocol ]] Mount the decorated view to the given path directly. Args path ( str ): The location for the view. converters ( Optional[Converters] ): Params converters for dynamic routing. routing ( Optional[RoutingStrategy] ): Routing strategy. url_for def url_for ( self , view : type [ AnyRequestHandlerProtocol ], params : Optional [ dict [ str , Any ]] = None , ) -> str Map view-class to path formatted with given params. Args view ( type[AnyRequestHandlerProtocol] ): The view-class for the url. params ( Optional[dict[str, Any]] ): Used to format dynamic path.","title":"Methods"},{"location":"api/blueprint-py/","text":"Module spangle.blueprint \u00b6 Application blueprint and router. Classes \u00b6 Blueprint \u00b6 class Blueprint ( self ) Application component contains child paths with views. Attributes views ( dict[str, tuple[type[AnyRequestHandlerProtocol], Converters, Optional[RoutingStrategy]]] ): Collected view classes. events ( LifespanHandlers ): Registered lifespan handlers. request_hooks ( dict[\"before\" | \"after\", list[type[RequestHandlerProtocol]]] ): Called against every request. Initialize self. Methods \u00b6 add_blueprint def add_blueprint ( self , path : str , bp : Blueprint ) -> None Nest a Blueprint in another one. Args path ( str ): Prefix for the blueprint. bp ( Blueprint ): Another instance to mount. after_request def after_request ( self , handler : type [ RequestHandlerProtocol ] ) -> type [ RequestHandlerProtocol ] Decorator to add a class called after each request processed. before_request def before_request ( self , handler : type [ RequestHandlerProtocol ] ) -> type [ RequestHandlerProtocol ] Decorator to add a class called before each request processed. handle def handle ( self , e : type [ Exception ] ) -> Callable [[ type [ ErrorHandlerProtocol ]], type [ ErrorHandlerProtocol ]] Bind Exception to the decorated view. Args e ( type[Exception] ): Subclass of Exception you want to handle. on_start def on_start ( self , f : LifespanFunction ) -> LifespanFunction Decorator for startup events. on_stop def on_stop ( self , f : LifespanFunction ) -> LifespanFunction Decorator for shutdown events. route def route ( self , path : str , * , converters : Optional [ Converters ] = None , routing : Optional [ RoutingStrategy ] = None , ) -> Callable [[ type [ AnyRequestHandlerProtocol ]], type [ AnyRequestHandlerProtocol ]] Bind a path to the decorated view. The path will be fixed by routing mode. Args path ( str ): The location of your view. converters ( Optional[Converters] ): Params converters for dynamic routing. routing ( Optional[RoutingStrategy] ): Routing strategy. Router \u00b6 class Router ( self , routing : RoutingStrategy ) Manage URLs and views. Do not use this manually. Initialize self. Methods \u00b6 get def get ( self , path : str ) -> Optional [ tuple [ type [ AnyRequestHandlerProtocol ], dict [ str , Any ]]] Find a view matching to path , or return None . Args path ( str ): Requested location. Returns Optional[tuple[type[AnyRequestHandlerProtocol], dict[str, Any]]] : View class and params parsed from path . RoutesMapping \u00b6 class RoutesMapping ( self , * args , ** kwargs ) Store collected pattern-view mapping. Base classes \u00b6 builtins.dict","title":"spangle.blueprint"},{"location":"api/blueprint-py/#module-spangleblueprint","text":"Application blueprint and router.","title":"Module spangle.blueprint"},{"location":"api/blueprint-py/#classes","text":"","title":"Classes"},{"location":"api/blueprint-py/#Blueprint","text":"class Blueprint ( self ) Application component contains child paths with views. Attributes views ( dict[str, tuple[type[AnyRequestHandlerProtocol], Converters, Optional[RoutingStrategy]]] ): Collected view classes. events ( LifespanHandlers ): Registered lifespan handlers. request_hooks ( dict[\"before\" | \"after\", list[type[RequestHandlerProtocol]]] ): Called against every request. Initialize self.","title":"Blueprint"},{"location":"api/blueprint-py/#Blueprint-methods","text":"add_blueprint def add_blueprint ( self , path : str , bp : Blueprint ) -> None Nest a Blueprint in another one. Args path ( str ): Prefix for the blueprint. bp ( Blueprint ): Another instance to mount. after_request def after_request ( self , handler : type [ RequestHandlerProtocol ] ) -> type [ RequestHandlerProtocol ] Decorator to add a class called after each request processed. before_request def before_request ( self , handler : type [ RequestHandlerProtocol ] ) -> type [ RequestHandlerProtocol ] Decorator to add a class called before each request processed. handle def handle ( self , e : type [ Exception ] ) -> Callable [[ type [ ErrorHandlerProtocol ]], type [ ErrorHandlerProtocol ]] Bind Exception to the decorated view. Args e ( type[Exception] ): Subclass of Exception you want to handle. on_start def on_start ( self , f : LifespanFunction ) -> LifespanFunction Decorator for startup events. on_stop def on_stop ( self , f : LifespanFunction ) -> LifespanFunction Decorator for shutdown events. route def route ( self , path : str , * , converters : Optional [ Converters ] = None , routing : Optional [ RoutingStrategy ] = None , ) -> Callable [[ type [ AnyRequestHandlerProtocol ]], type [ AnyRequestHandlerProtocol ]] Bind a path to the decorated view. The path will be fixed by routing mode. Args path ( str ): The location of your view. converters ( Optional[Converters] ): Params converters for dynamic routing. routing ( Optional[RoutingStrategy] ): Routing strategy.","title":"Methods"},{"location":"api/blueprint-py/#Router","text":"class Router ( self , routing : RoutingStrategy ) Manage URLs and views. Do not use this manually. Initialize self.","title":"Router"},{"location":"api/blueprint-py/#Router-methods","text":"get def get ( self , path : str ) -> Optional [ tuple [ type [ AnyRequestHandlerProtocol ], dict [ str , Any ]]] Find a view matching to path , or return None . Args path ( str ): Requested location. Returns Optional[tuple[type[AnyRequestHandlerProtocol], dict[str, Any]]] : View class and params parsed from path .","title":"Methods"},{"location":"api/blueprint-py/#RoutesMapping","text":"class RoutesMapping ( self , * args , ** kwargs ) Store collected pattern-view mapping.","title":"RoutesMapping"},{"location":"api/blueprint-py/#RoutesMapping-bases","text":"builtins.dict","title":"Base classes"},{"location":"api/component-py/","text":"Module spangle.component \u00b6 Component tools. Classes \u00b6 AsyncShutdownComponentProtocol \u00b6 class AsyncShutdownComponentProtocol ( * args , ** kwargs ) Component must be initialized without arguments. Base classes \u00b6 ComponentProtocol Methods \u00b6 shutdown async def shutdown ( self ) -> None Called on server shutdown. To access other components, use use_component . AsyncStartupComponentProtocol \u00b6 class AsyncStartupComponentProtocol ( * args , ** kwargs ) Component must be initialized without arguments. Base classes \u00b6 ComponentProtocol Methods \u00b6 startup async def startup ( self ) -> None Called on server startup. To access other components, use use_component . ComponentProtocol \u00b6 class ComponentProtocol ( self ) Component must be initialized without arguments. Base classes \u00b6 typing.Protocol ComponentsCache \u00b6 class ComponentsCache ( self ) Store registered component instances based on its context. Initialize self. See help(type(self)) for accurate signature. SyncShutdownComponentProtocol \u00b6 class SyncShutdownComponentProtocol ( * args , ** kwargs ) Component must be initialized without arguments. Base classes \u00b6 ComponentProtocol Methods \u00b6 shutdown def shutdown ( self ) -> None Called on server shutdown. To access other components, use use_component . SyncStartupComponentProtocol \u00b6 class SyncStartupComponentProtocol ( * args , ** kwargs ) Component must be initialized without arguments. Base classes \u00b6 ComponentProtocol Methods \u00b6 startup def startup ( self ) -> None Called on server startup. To access other components, use use_component . Functions \u00b6 use_api \u00b6 def use_api () -> Api Return Api instance. Returns Api Raises KeyError : Called out of api context. use_component \u00b6 def use_component ( component : type [ T ], * , api : Optional [ Api ] = None ) -> T Return registered component instance. Args component ( type[spangle.component.AnyComponentProtocol] ): Component class. api ( Optional[spangle.api.Api] ): Api instance to use its context. Default: None (use current context) Returns Registered component instance. Raises KeyError : The component is not registered.","title":"spangle.component"},{"location":"api/component-py/#module-spanglecomponent","text":"Component tools.","title":"Module spangle.component"},{"location":"api/component-py/#classes","text":"","title":"Classes"},{"location":"api/component-py/#AsyncShutdownComponentProtocol","text":"class AsyncShutdownComponentProtocol ( * args , ** kwargs ) Component must be initialized without arguments.","title":"AsyncShutdownComponentProtocol"},{"location":"api/component-py/#AsyncShutdownComponentProtocol-bases","text":"ComponentProtocol","title":"Base classes"},{"location":"api/component-py/#AsyncShutdownComponentProtocol-methods","text":"shutdown async def shutdown ( self ) -> None Called on server shutdown. To access other components, use use_component .","title":"Methods"},{"location":"api/component-py/#AsyncStartupComponentProtocol","text":"class AsyncStartupComponentProtocol ( * args , ** kwargs ) Component must be initialized without arguments.","title":"AsyncStartupComponentProtocol"},{"location":"api/component-py/#AsyncStartupComponentProtocol-bases","text":"ComponentProtocol","title":"Base classes"},{"location":"api/component-py/#AsyncStartupComponentProtocol-methods","text":"startup async def startup ( self ) -> None Called on server startup. To access other components, use use_component .","title":"Methods"},{"location":"api/component-py/#ComponentProtocol","text":"class ComponentProtocol ( self ) Component must be initialized without arguments.","title":"ComponentProtocol"},{"location":"api/component-py/#ComponentProtocol-bases","text":"typing.Protocol","title":"Base classes"},{"location":"api/component-py/#ComponentsCache","text":"class ComponentsCache ( self ) Store registered component instances based on its context. Initialize self. See help(type(self)) for accurate signature.","title":"ComponentsCache"},{"location":"api/component-py/#SyncShutdownComponentProtocol","text":"class SyncShutdownComponentProtocol ( * args , ** kwargs ) Component must be initialized without arguments.","title":"SyncShutdownComponentProtocol"},{"location":"api/component-py/#SyncShutdownComponentProtocol-bases","text":"ComponentProtocol","title":"Base classes"},{"location":"api/component-py/#SyncShutdownComponentProtocol-methods","text":"shutdown def shutdown ( self ) -> None Called on server shutdown. To access other components, use use_component .","title":"Methods"},{"location":"api/component-py/#SyncStartupComponentProtocol","text":"class SyncStartupComponentProtocol ( * args , ** kwargs ) Component must be initialized without arguments.","title":"SyncStartupComponentProtocol"},{"location":"api/component-py/#SyncStartupComponentProtocol-bases","text":"ComponentProtocol","title":"Base classes"},{"location":"api/component-py/#SyncStartupComponentProtocol-methods","text":"startup def startup ( self ) -> None Called on server startup. To access other components, use use_component .","title":"Methods"},{"location":"api/component-py/#functions","text":"","title":"Functions"},{"location":"api/component-py/#use_api","text":"def use_api () -> Api Return Api instance. Returns Api Raises KeyError : Called out of api context.","title":"use_api"},{"location":"api/component-py/#use_component","text":"def use_component ( component : type [ T ], * , api : Optional [ Api ] = None ) -> T Return registered component instance. Args component ( type[spangle.component.AnyComponentProtocol] ): Component class. api ( Optional[spangle.api.Api] ): Api instance to use its context. Default: None (use current context) Returns Registered component instance. Raises KeyError : The component is not registered.","title":"use_component"},{"location":"api/error_handler-py/","text":"Module spangle.error_handler \u00b6 Application blueprint for Exception . Classes \u00b6 ErrorHandler \u00b6 class ErrorHandler ( self ) When exceptions are raised, Api calls registered view. Initialize self. Methods \u00b6 handle def handle ( self , e : type [ Exception ] ) -> Callable [[ type [ ErrorHandlerProtocol ]], type [ ErrorHandlerProtocol ]] Bind Exception to the decolated view. Args e ( type[Exception] ): Subclass of Exception you want to handle.","title":"spangle.error_handler"},{"location":"api/error_handler-py/#module-spangleerror_handler","text":"Application blueprint for Exception .","title":"Module spangle.error_handler"},{"location":"api/error_handler-py/#classes","text":"","title":"Classes"},{"location":"api/error_handler-py/#ErrorHandler","text":"class ErrorHandler ( self ) When exceptions are raised, Api calls registered view. Initialize self.","title":"ErrorHandler"},{"location":"api/error_handler-py/#ErrorHandler-methods","text":"handle def handle ( self , e : type [ Exception ] ) -> Callable [[ type [ ErrorHandlerProtocol ]], type [ ErrorHandlerProtocol ]] Bind Exception to the decolated view. Args e ( type[Exception] ): Subclass of Exception you want to handle.","title":"Methods"},{"location":"api/exceptions-py/","text":"Module spangle.exceptions \u00b6 spangle exceptions. Classes \u00b6 MethodNotAllowedError \u00b6 class MethodNotAllowedError ( self , message = \"Method not allowed.\" , status = HTTPStatus . METHOD_NOT_ALLOWED , allowed_methods : set [ str ] = None ,) 405: Unexpected method. Safe methods like GET will be accepted anytime. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers. Base classes \u00b6 SpangleError NotFoundError \u00b6 class NotFoundError ( self , message = \"Content not found.\" , status = HTTPStatus . NOT_FOUND ) 404: Missing resources, views, etc. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers. Base classes \u00b6 SpangleError ParseError \u00b6 class ParseError ( self , message = \"Unsupported format.\" , status = HTTPStatus . BAD_REQUEST ) 400: Raised by parser. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers. Base classes \u00b6 SpangleError builtins.ValueError SpangleError \u00b6 class SpangleError ( self , message = \"Something wrong.\" , status = HTTPStatus . INTERNAL_SERVER_ERROR , headers : dict [ str , str ] = None ,) 500: Base class of spangle-errors. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers. Base classes \u00b6 builtins.Exception TooLargeRequestError \u00b6 class TooLargeRequestError ( self , message = \"Payload too large.\" , status = HTTPStatus . REQUEST_ENTITY_TOO_LARGE ) 413: Payload Too Large. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers. Base classes \u00b6 SpangleError","title":"spangle.exceptions"},{"location":"api/exceptions-py/#module-spangleexceptions","text":"spangle exceptions.","title":"Module spangle.exceptions"},{"location":"api/exceptions-py/#classes","text":"","title":"Classes"},{"location":"api/exceptions-py/#MethodNotAllowedError","text":"class MethodNotAllowedError ( self , message = \"Method not allowed.\" , status = HTTPStatus . METHOD_NOT_ALLOWED , allowed_methods : set [ str ] = None ,) 405: Unexpected method. Safe methods like GET will be accepted anytime. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers.","title":"MethodNotAllowedError"},{"location":"api/exceptions-py/#MethodNotAllowedError-bases","text":"SpangleError","title":"Base classes"},{"location":"api/exceptions-py/#NotFoundError","text":"class NotFoundError ( self , message = \"Content not found.\" , status = HTTPStatus . NOT_FOUND ) 404: Missing resources, views, etc. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers.","title":"NotFoundError"},{"location":"api/exceptions-py/#NotFoundError-bases","text":"SpangleError","title":"Base classes"},{"location":"api/exceptions-py/#ParseError","text":"class ParseError ( self , message = \"Unsupported format.\" , status = HTTPStatus . BAD_REQUEST ) 400: Raised by parser. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers.","title":"ParseError"},{"location":"api/exceptions-py/#ParseError-bases","text":"SpangleError builtins.ValueError","title":"Base classes"},{"location":"api/exceptions-py/#SpangleError","text":"class SpangleError ( self , message = \"Something wrong.\" , status = HTTPStatus . INTERNAL_SERVER_ERROR , headers : dict [ str , str ] = None ,) 500: Base class of spangle-errors. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers.","title":"SpangleError"},{"location":"api/exceptions-py/#SpangleError-bases","text":"builtins.Exception","title":"Base classes"},{"location":"api/exceptions-py/#TooLargeRequestError","text":"class TooLargeRequestError ( self , message = \"Payload too large.\" , status = HTTPStatus . REQUEST_ENTITY_TOO_LARGE ) 413: Payload Too Large. Args message ( str ): Print on error page. status ( int ): HTTP status code. headers ( dict[str, str] ): HTTP headers.","title":"TooLargeRequestError"},{"location":"api/exceptions-py/#TooLargeRequestError-bases","text":"SpangleError","title":"Base classes"},{"location":"api/handler_protocols-py/","text":"Module spangle.handler_protocols \u00b6 Protocols of request/error handler. Classes \u00b6 BaseHandlerProtocol \u00b6 class BaseHandlerProtocol ( self ) Every handler class should initialize without args. Base classes \u00b6 typing.Protocol DeleteHandlerProtocol \u00b6 class DeleteHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args. Base classes \u00b6 BaseHandlerProtocol Methods \u00b6 on_delete async def on_delete ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ] GetHandlerProtocol \u00b6 class GetHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args. Base classes \u00b6 BaseHandlerProtocol Methods \u00b6 on_get async def on_get ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ] HttpErrorHandlerProtocol \u00b6 class HttpErrorHandlerProtocol ( * args , ** kwargs ) Error handler must implement on_error . Base classes \u00b6 BaseHandlerProtocol Methods \u00b6 on_error async def on_error ( self , req : Request , resp : Response , e : E , / ) -> Optional [ Response ] PatchHandlerProtocol \u00b6 class PatchHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args. Base classes \u00b6 BaseHandlerProtocol Methods \u00b6 on_patch async def on_patch ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ] PostHandlerProtocol \u00b6 class PostHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args. Base classes \u00b6 BaseHandlerProtocol Methods \u00b6 on_post async def on_post ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ] PutHandlerProtocol \u00b6 class PutHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args. Base classes \u00b6 BaseHandlerProtocol Methods \u00b6 on_put async def on_put ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ] RequestHandlerProtocol \u00b6 class RequestHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args. Base classes \u00b6 BaseHandlerProtocol Methods \u00b6 on_request async def on_request ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ] WebSocketErrorHandlerProtocol \u00b6 class WebSocketErrorHandlerProtocol ( * args , ** kwargs ) Error handler must implement on_ws_error . Base classes \u00b6 BaseHandlerProtocol Methods \u00b6 on_ws_error async def on_ws_error ( self , conn : Connection , e : E , / ) -> None WebsocketHandlerProtocol \u00b6 class WebsocketHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args. Base classes \u00b6 BaseHandlerProtocol Methods \u00b6 on_ws async def on_ws ( self , conn : Connection , / , ** kw : Any ) -> None","title":"spangle.handler_protocols"},{"location":"api/handler_protocols-py/#module-spanglehandler_protocols","text":"Protocols of request/error handler.","title":"Module spangle.handler_protocols"},{"location":"api/handler_protocols-py/#classes","text":"","title":"Classes"},{"location":"api/handler_protocols-py/#BaseHandlerProtocol","text":"class BaseHandlerProtocol ( self ) Every handler class should initialize without args.","title":"BaseHandlerProtocol"},{"location":"api/handler_protocols-py/#BaseHandlerProtocol-bases","text":"typing.Protocol","title":"Base classes"},{"location":"api/handler_protocols-py/#DeleteHandlerProtocol","text":"class DeleteHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args.","title":"DeleteHandlerProtocol"},{"location":"api/handler_protocols-py/#DeleteHandlerProtocol-bases","text":"BaseHandlerProtocol","title":"Base classes"},{"location":"api/handler_protocols-py/#DeleteHandlerProtocol-methods","text":"on_delete async def on_delete ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ]","title":"Methods"},{"location":"api/handler_protocols-py/#GetHandlerProtocol","text":"class GetHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args.","title":"GetHandlerProtocol"},{"location":"api/handler_protocols-py/#GetHandlerProtocol-bases","text":"BaseHandlerProtocol","title":"Base classes"},{"location":"api/handler_protocols-py/#GetHandlerProtocol-methods","text":"on_get async def on_get ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ]","title":"Methods"},{"location":"api/handler_protocols-py/#HttpErrorHandlerProtocol","text":"class HttpErrorHandlerProtocol ( * args , ** kwargs ) Error handler must implement on_error .","title":"HttpErrorHandlerProtocol"},{"location":"api/handler_protocols-py/#HttpErrorHandlerProtocol-bases","text":"BaseHandlerProtocol","title":"Base classes"},{"location":"api/handler_protocols-py/#HttpErrorHandlerProtocol-methods","text":"on_error async def on_error ( self , req : Request , resp : Response , e : E , / ) -> Optional [ Response ]","title":"Methods"},{"location":"api/handler_protocols-py/#PatchHandlerProtocol","text":"class PatchHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args.","title":"PatchHandlerProtocol"},{"location":"api/handler_protocols-py/#PatchHandlerProtocol-bases","text":"BaseHandlerProtocol","title":"Base classes"},{"location":"api/handler_protocols-py/#PatchHandlerProtocol-methods","text":"on_patch async def on_patch ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ]","title":"Methods"},{"location":"api/handler_protocols-py/#PostHandlerProtocol","text":"class PostHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args.","title":"PostHandlerProtocol"},{"location":"api/handler_protocols-py/#PostHandlerProtocol-bases","text":"BaseHandlerProtocol","title":"Base classes"},{"location":"api/handler_protocols-py/#PostHandlerProtocol-methods","text":"on_post async def on_post ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ]","title":"Methods"},{"location":"api/handler_protocols-py/#PutHandlerProtocol","text":"class PutHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args.","title":"PutHandlerProtocol"},{"location":"api/handler_protocols-py/#PutHandlerProtocol-bases","text":"BaseHandlerProtocol","title":"Base classes"},{"location":"api/handler_protocols-py/#PutHandlerProtocol-methods","text":"on_put async def on_put ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ]","title":"Methods"},{"location":"api/handler_protocols-py/#RequestHandlerProtocol","text":"class RequestHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args.","title":"RequestHandlerProtocol"},{"location":"api/handler_protocols-py/#RequestHandlerProtocol-bases","text":"BaseHandlerProtocol","title":"Base classes"},{"location":"api/handler_protocols-py/#RequestHandlerProtocol-methods","text":"on_request async def on_request ( self , req : Request , resp : Response , / , ** kw : Any ) -> Optional [ Response ]","title":"Methods"},{"location":"api/handler_protocols-py/#WebSocketErrorHandlerProtocol","text":"class WebSocketErrorHandlerProtocol ( * args , ** kwargs ) Error handler must implement on_ws_error .","title":"WebSocketErrorHandlerProtocol"},{"location":"api/handler_protocols-py/#WebSocketErrorHandlerProtocol-bases","text":"BaseHandlerProtocol","title":"Base classes"},{"location":"api/handler_protocols-py/#WebSocketErrorHandlerProtocol-methods","text":"on_ws_error async def on_ws_error ( self , conn : Connection , e : E , / ) -> None","title":"Methods"},{"location":"api/handler_protocols-py/#WebsocketHandlerProtocol","text":"class WebsocketHandlerProtocol ( * args , ** kwargs ) Every handler class should initialize without args.","title":"WebsocketHandlerProtocol"},{"location":"api/handler_protocols-py/#WebsocketHandlerProtocol-bases","text":"BaseHandlerProtocol","title":"Base classes"},{"location":"api/handler_protocols-py/#WebsocketHandlerProtocol-methods","text":"on_ws async def on_ws ( self , conn : Connection , / , ** kw : Any ) -> None","title":"Methods"},{"location":"api/parser-py/","text":"Module spangle.parser \u00b6 Types to parse user uploads. Classes \u00b6 UploadedFile \u00b6 class UploadedFile ( filename : ForwardRef ( 'str' ), file : ForwardRef ( 'SpooledTemporaryFile' ), mimetype : ForwardRef ( 'str' )) Named tuple to accept client\u2019s uploads via multipart/form-data . Attributes filename ( str ): Filename, includes .ext . file ( SpooledTemporaryFile ): File-like object. mimetype ( str ): File\u2019s \"mime/type\" . Base classes \u00b6 builtins.tuple","title":"spangle.parser"},{"location":"api/parser-py/#module-spangleparser","text":"Types to parse user uploads.","title":"Module spangle.parser"},{"location":"api/parser-py/#classes","text":"","title":"Classes"},{"location":"api/parser-py/#UploadedFile","text":"class UploadedFile ( filename : ForwardRef ( 'str' ), file : ForwardRef ( 'SpooledTemporaryFile' ), mimetype : ForwardRef ( 'str' )) Named tuple to accept client\u2019s uploads via multipart/form-data . Attributes filename ( str ): Filename, includes .ext . file ( SpooledTemporaryFile ): File-like object. mimetype ( str ): File\u2019s \"mime/type\" .","title":"UploadedFile"},{"location":"api/parser-py/#UploadedFile-bases","text":"builtins.tuple","title":"Base classes"},{"location":"api/testing-py/","text":"Module spangle.testing \u00b6 Test client for ASGI app without ASGI server. Classes \u00b6 AsyncHttpTestClient \u00b6 class AsyncHttpTestClient ( self , app : ASGIApp , timeout : Union [ int , float , None ] = 1 , host = \"www.example.com\" , client = ( \"127.0.0.1\" , 123 ),) Mock HTTP client without running server. Lifespan-event is supported by async with statement. Args app ( ASGIApp ): Application instance. timeout ( Optional[int] ): Timeout seconds. host ( str ): Temporary host name. client ( tuple[str, int] ): Client address. Base classes \u00b6 spangle.testing._BaseClient Methods \u00b6 delete async def delete ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send DELETE request to app . See spangle.testing.AsyncHttpTestClient.request . get async def get ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send GET request to app . See spangle.testing.AsyncHttpTestClient.request . patch async def patch ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , json : Mapping = None , files : Mapping = None , form : Mapping = None , content : bytes = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send PATCH request to app . See spangle.testing.AsyncHttpTestClient.request . post async def post ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , json : Mapping = None , files : Mapping = None , form : Mapping = None , content : bytes = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send POST request to app . See spangle.testing.AsyncHttpTestClient.request . put async def put ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , json : Mapping = None , files : Mapping = None , form : Mapping = None , content : bytes = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send PUT request to app . See spangle.testing.AsyncHttpTestClient.request . request async def request ( self , method : str , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , json : Mapping = None , files : Mapping = None , form : Mapping = None , content : bytes = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send request to app . Args method ( str ): HTTP request method. path ( str ): Requesting location. params ( Params ): Querystring as dict or list of (name, value) . headers ( Headers ): HTTP headers. cookies ( Mapping ): Sending HTTP cookies. json ( Mapping ): Request body as json. files ( Mapping ): Multipart form. form ( Mapping ): URL encoded form. content ( bytes ): Request body as bytes. timeout ( int ): Wait limits. allow_redirects ( bool ): If False , a client gets 30X response instead of redirection. Returns HttpTestResponse ws_connect def ws_connect ( self , path : str , subprotocols : list [ str ] = None , params : Params = None , headers : Headers = None , cookies : Mapping = None , timeout : int = None , ) -> AsyncWebsocketClient Create asynchronous WebSocket Connection. AsyncWebsocketClient \u00b6 class AsyncWebsocketClient ( self , http : \"AsyncHttpTestClient\" , path : str = \"\" , headers : CIMultiDict = None , params : Params = None , cookies : Mapping = None , timeout : int = None ,) Asynchronous WebSocket test client. It is expected to be called from AsyncHttpTestClient . Attributes host ( str ): Dummy domain. path ( str ): WebSocket endpoint. headers ( CIMultiDict ): Headers used to connect. params ( Params ): Parsed querystrings. timeout ( Optional[int] ): How long test client waits for. Do not use manually. Base classes \u00b6 spangle.testing._BaseWebSocket Methods \u00b6 close async def close ( self , status_code = 1000 ) Close the connection. Args status_code ( int ): WebSocket status code. connect async def connect ( self , path : str = None ) Emulate WebSocket Connection. Args path ( Optional[str] ): Overwrite self.path . receive async def receive ( self , mode : type [ AnyStr ]) -> AnyStr Receive data from the endpoint. Args mode ( type[AnyStr] ): Receiving type, str or bytes . Returns AnyStr : Data with specified type. send async def send ( self , data : AnyStr ) Send data to the endpoint. Args data ( AnyStr ): Data sent to the endpoint, must be str or bytes . HttpTestResponse \u00b6 class HttpTestResponse ( self , resp : Response ) Response for testing. Attributes status_code ( int ): HTTPStatus if available, or just int . Do not use manually. Instance attributes \u00b6 content ( Optional[bytes] ): Response body, as bytes . cookies ( Cookies ): Dict-like response cookies. headers ( CIMultiDict ): Response header, as dict . json ( addict.Dict ): Json response. Dot access available, like resp.json.what.you.want . text ( Optional[str] ): Response body, as UTF-8 text.","title":"spangle.testing"},{"location":"api/testing-py/#module-spangletesting","text":"Test client for ASGI app without ASGI server.","title":"Module spangle.testing"},{"location":"api/testing-py/#classes","text":"","title":"Classes"},{"location":"api/testing-py/#AsyncHttpTestClient","text":"class AsyncHttpTestClient ( self , app : ASGIApp , timeout : Union [ int , float , None ] = 1 , host = \"www.example.com\" , client = ( \"127.0.0.1\" , 123 ),) Mock HTTP client without running server. Lifespan-event is supported by async with statement. Args app ( ASGIApp ): Application instance. timeout ( Optional[int] ): Timeout seconds. host ( str ): Temporary host name. client ( tuple[str, int] ): Client address.","title":"AsyncHttpTestClient"},{"location":"api/testing-py/#AsyncHttpTestClient-bases","text":"spangle.testing._BaseClient","title":"Base classes"},{"location":"api/testing-py/#AsyncHttpTestClient-methods","text":"delete async def delete ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send DELETE request to app . See spangle.testing.AsyncHttpTestClient.request . get async def get ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send GET request to app . See spangle.testing.AsyncHttpTestClient.request . patch async def patch ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , json : Mapping = None , files : Mapping = None , form : Mapping = None , content : bytes = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send PATCH request to app . See spangle.testing.AsyncHttpTestClient.request . post async def post ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , json : Mapping = None , files : Mapping = None , form : Mapping = None , content : bytes = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send POST request to app . See spangle.testing.AsyncHttpTestClient.request . put async def put ( self , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , json : Mapping = None , files : Mapping = None , form : Mapping = None , content : bytes = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send PUT request to app . See spangle.testing.AsyncHttpTestClient.request . request async def request ( self , method : str , path : str , params : Params = None , headers : Headers = None , cookies : Mapping = None , json : Mapping = None , files : Mapping = None , form : Mapping = None , content : bytes = None , timeout : int = None , allow_redirects = True , ) -> HttpTestResponse Send request to app . Args method ( str ): HTTP request method. path ( str ): Requesting location. params ( Params ): Querystring as dict or list of (name, value) . headers ( Headers ): HTTP headers. cookies ( Mapping ): Sending HTTP cookies. json ( Mapping ): Request body as json. files ( Mapping ): Multipart form. form ( Mapping ): URL encoded form. content ( bytes ): Request body as bytes. timeout ( int ): Wait limits. allow_redirects ( bool ): If False , a client gets 30X response instead of redirection. Returns HttpTestResponse ws_connect def ws_connect ( self , path : str , subprotocols : list [ str ] = None , params : Params = None , headers : Headers = None , cookies : Mapping = None , timeout : int = None , ) -> AsyncWebsocketClient Create asynchronous WebSocket Connection.","title":"Methods"},{"location":"api/testing-py/#AsyncWebsocketClient","text":"class AsyncWebsocketClient ( self , http : \"AsyncHttpTestClient\" , path : str = \"\" , headers : CIMultiDict = None , params : Params = None , cookies : Mapping = None , timeout : int = None ,) Asynchronous WebSocket test client. It is expected to be called from AsyncHttpTestClient . Attributes host ( str ): Dummy domain. path ( str ): WebSocket endpoint. headers ( CIMultiDict ): Headers used to connect. params ( Params ): Parsed querystrings. timeout ( Optional[int] ): How long test client waits for. Do not use manually.","title":"AsyncWebsocketClient"},{"location":"api/testing-py/#AsyncWebsocketClient-bases","text":"spangle.testing._BaseWebSocket","title":"Base classes"},{"location":"api/testing-py/#AsyncWebsocketClient-methods","text":"close async def close ( self , status_code = 1000 ) Close the connection. Args status_code ( int ): WebSocket status code. connect async def connect ( self , path : str = None ) Emulate WebSocket Connection. Args path ( Optional[str] ): Overwrite self.path . receive async def receive ( self , mode : type [ AnyStr ]) -> AnyStr Receive data from the endpoint. Args mode ( type[AnyStr] ): Receiving type, str or bytes . Returns AnyStr : Data with specified type. send async def send ( self , data : AnyStr ) Send data to the endpoint. Args data ( AnyStr ): Data sent to the endpoint, must be str or bytes .","title":"Methods"},{"location":"api/testing-py/#HttpTestResponse","text":"class HttpTestResponse ( self , resp : Response ) Response for testing. Attributes status_code ( int ): HTTPStatus if available, or just int . Do not use manually.","title":"HttpTestResponse"},{"location":"api/testing-py/#HttpTestResponse-attrs","text":"content ( Optional[bytes] ): Response body, as bytes . cookies ( Cookies ): Dict-like response cookies. headers ( CIMultiDict ): Response header, as dict . json ( addict.Dict ): Json response. Dot access available, like resp.json.what.you.want . text ( Optional[str] ): Response body, as UTF-8 text.","title":"Instance attributes"},{"location":"api/types-py/","text":"Module spangle.types \u00b6 Utility types for spangle . Classes \u00b6 LifespanHandlers \u00b6 class LifespanHandlers ( self , * args , ** kwargs ) Contains functions called on startup/shutdown. Base classes \u00b6 builtins.dict","title":"spangle.types"},{"location":"api/types-py/#module-spangletypes","text":"Utility types for spangle .","title":"Module spangle.types"},{"location":"api/types-py/#classes","text":"","title":"Classes"},{"location":"api/types-py/#LifespanHandlers","text":"class LifespanHandlers ( self , * args , ** kwargs ) Contains functions called on startup/shutdown.","title":"LifespanHandlers"},{"location":"api/types-py/#LifespanHandlers-bases","text":"builtins.dict","title":"Base classes"},{"location":"api/cli/","text":"Module spangle.cli \u00b6 Submodules \u00b6 spangle.cli.run","title":"spangle.cli"},{"location":"api/cli/#module-spanglecli","text":"","title":"Module spangle.cli"},{"location":"api/cli/#submodules","text":"spangle.cli.run","title":"Submodules"},{"location":"api/cli/run-py/","text":"Module spangle.cli.run \u00b6 Functions \u00b6 main \u00b6 def main () urls_ts \u00b6 def urls_ts ( args : argparse . Namespace ) -> None Print url_for function written in TypeScript. API is a place of your spangle app, like \u201cpath.to.file:instance\u201d.","title":"spangle.cli.run"},{"location":"api/cli/run-py/#module-spangleclirun","text":"","title":"Module spangle.cli.run"},{"location":"api/cli/run-py/#functions","text":"","title":"Functions"},{"location":"api/cli/run-py/#main","text":"def main ()","title":"main"},{"location":"api/cli/run-py/#urls_ts","text":"def urls_ts ( args : argparse . Namespace ) -> None Print url_for function written in TypeScript. API is a place of your spangle app, like \u201cpath.to.file:instance\u201d.","title":"urls_ts"},{"location":"api/models/","text":"Module spangle.models \u00b6 Submodules \u00b6 spangle.models.http spangle.models.websocket","title":"spangle.models"},{"location":"api/models/#module-spanglemodels","text":"","title":"Module spangle.models"},{"location":"api/models/#submodules","text":"spangle.models.http spangle.models.websocket","title":"Submodules"},{"location":"api/models/http-py/","text":"Module spangle.models.http \u00b6 HTTP Request & Response. Classes \u00b6 Request \u00b6 class Request ( self , scope : Scope , receive : Receive , send : Send ) Incoming HTTP request class. Attributes headers ( CIMultiDictProxy ): The request headers, case-insensitive dictionary. state ( addict.Dict ): Any object you want to store while the response. max_upload_bytes ( int ): Limit upload size against each request. Do not use manually. Instance attributes \u00b6 apparent_encoding ( Dict[str, Union[str, float]] ): Guess the content encoding, provided by the chardet library. Must be awaited. client ( Address ): The client address. Attributes host ( Optional[str] ): The client address, like \"127.0.0.1\" . port ( Optional[int] ): The client port, like 1234 . content ( bytes ): The request body, as bytes. Must be awaited. Raises TooLargeRequestError : when request body is too large. cookies ( dict[str, str] ): The cookies sent in the request, as a dictionary. full_url ( str ): The full URL of the request. method ( str ): The request method, lower-cased. mimetype ( str ): Mimetype of the request\u2019s body, or \"\" . params ( MultiDictProxy ): The parsed query parameters used for the request. text ( str ): The request body, as unicode-decoded. Must be awaited. url ( URL ): The parsed URL of the request. For more details, see Starlette docs . version ( str ): The HTTP version, like \"1.1\" , \"2\" . Methods \u00b6 accept def accept ( self , content_type : str ) -> Optional [ tuple [ str , float ]] Test given type is acceptable or not. Args content_type ( str ): Testing \"mime/type\" . Returns Optional[ tuple[str, float] ]: The first accepted type and its priority in the range: 0.0<=q<=1.0 , or None . media async def media ( self , parser : Callable [[ \"Request\" ], Awaitable [ Any ]] = None , parse_as : str = None , ) -> Union [ MultiDictProxy , Any ] Decode the request body to dict-like object. Must be awaited. You can use custom parser by setting your function. Args parser ( Optional[Callable[[Request], Awaitable[Any]]] ): Custom parser, must be async function. If not given, spangle uses builtin parser. parse_as ( Optional[str] ): Select parser to decode the body. Accept \"json\" , \"form\" , or \"multipart\" . Returns MultiDictProxy : May be overridden by custom parser. push async def push ( self , path : str ) -> None HTTP2 push-promise. Args path ( str ): A content location in the app. Response \u00b6 class Response ( self , jinja_env : jinja2 . Environment = None , url_for = None ) Outgoing HTTP response class. Response instance is ASGI3 application. Attributes headers ( CIMultiDict ): The response headers, case-insensitive dictionary. To set values having same key, use headers.add() . cookies ( SimpleCookie ): Dict-like http cookies. Set-Cookie header refers this. You can set cookie-attributes. status ( int ): The response\u2019s status code. streaming ( Optional[AsyncGenerator] ): Async generator for streaming. If set, other response body attrs like media are ignored. mimetype ( str ): The mediatype of the response body. reraise ( bool ): In ErrorHandler, if set true, reraise the exception after sending data. Do not use manually. Instance attributes \u00b6 content ( bytes ): Bytes of the response body. Default-type: \"application/octet-stream\" . json ( Any ): A dict sent to the client. Default-type: \"application/json\" . You can set values like resp.json.keyName.you = \"want\" . text ( str ): A unicode string of the response body. Default-type: \"text/plain\" . Methods \u00b6 add_header def add_header ( self , key : str , value : str ) -> \"Response\" Append new header. To overwrite, use spangle.models.http.Response.set_header . Args key ( str ): Header\u2019s key. value ( str ): Header\u2019s value. Returns Response : Return self. delete_cookie def delete_cookie ( self , key : str , path : str = \"/\" , domain : str = None ) -> \"Response\" Remove cookie value from client. Args key ( str ) Cookie options: path ( str ) domain ( str ) Returns Response : Return self. load_template async def load_template ( self , template_name : str , content_type = \"text/html\" , ** params ) -> \"Response\" Load jinja2 template, render, set headers & text. Args template_name ( str ): The template \"path/name\" . content_type ( str ): \"text/html\" . **params : Variables used in the template. api is reserved by Api instance by default. Returns Response : Return self. Raises ValueError : Missing jinja2 env in Api instance. NotFoundError : Missing requested template. redirect def redirect ( self , * , view : type = None , params : dict = None , url : str = None , status = HTTPStatus . TEMPORARY_REDIRECT , query_string : Optional [ str ] = None , ) -> \"Response\" Set redirect view/location. Positional args are not allowed. If both view and url are set, url is ignored. Args view ( Type ): View class that the client redirect to. params ( dict ): Dynamic URL params passed to the view. url ( str ): The location out of the app. status ( int ): HTTP status code. Must be 300<=status<400 . Returns Response : Return self. set_content def set_content ( self , content : bytes , content_type = \"application/octet-stream\" ) -> \"Response\" Set bytes to response body with content type. Args content ( bytes ): Response body as bytes. content_type ( str ): Response content type. Returns Response : Return self. set_cookie def set_cookie ( self , key : str , value : str = \"\" , max_age : Optional [ int ] = None , expires : Optional [ int ] = None , path : Optional [ str ] = \"/\" , comment : Optional [ str ] = None , domain : Optional [ str ] = None , secure : bool = False , httponly : bool = True , version : Optional [ int ] = None , samesite : Optional [ str ] = \"Lax\" , ) -> \"Response\" Set cookie value to given key with params. Args key ( str ) value ( str ) Cookie options: max_age ( Optional[int] ) expires ( Optional[int] ) path ( Optional[str] ) comment ( Optional[str] ) domain ( Optional[str] ) secure ( bool ) httponly ( bool ) version ( Optional[int] ) samesite ( Optional[str] ) Returns Response : Return self. set_header def set_header ( self , key : str , value : str ) -> \"Response\" Set HTTP header value to given key. It overwrites value if exists. Args key ( str ): Header\u2019s key. value ( str ): Header\u2019s value. Returns Response : Return self. set_status def set_status ( self , status : int ) -> \"Response\" Set HTTP status code. Args status ( int ): HTTP status code. Returns Response : Return self. set_text def set_text ( self , text : str , content_type = \"text/plain\" ) -> \"Response\" Set given text to response body with content type. Args text ( str ): Response body as UTF-8 string. content_type ( str ): Response content type. Returns Response : Return self.","title":"spangle.models.http"},{"location":"api/models/http-py/#module-spanglemodelshttp","text":"HTTP Request & Response.","title":"Module spangle.models.http"},{"location":"api/models/http-py/#classes","text":"","title":"Classes"},{"location":"api/models/http-py/#Request","text":"class Request ( self , scope : Scope , receive : Receive , send : Send ) Incoming HTTP request class. Attributes headers ( CIMultiDictProxy ): The request headers, case-insensitive dictionary. state ( addict.Dict ): Any object you want to store while the response. max_upload_bytes ( int ): Limit upload size against each request. Do not use manually.","title":"Request"},{"location":"api/models/http-py/#Request-attrs","text":"apparent_encoding ( Dict[str, Union[str, float]] ): Guess the content encoding, provided by the chardet library. Must be awaited. client ( Address ): The client address. Attributes host ( Optional[str] ): The client address, like \"127.0.0.1\" . port ( Optional[int] ): The client port, like 1234 . content ( bytes ): The request body, as bytes. Must be awaited. Raises TooLargeRequestError : when request body is too large. cookies ( dict[str, str] ): The cookies sent in the request, as a dictionary. full_url ( str ): The full URL of the request. method ( str ): The request method, lower-cased. mimetype ( str ): Mimetype of the request\u2019s body, or \"\" . params ( MultiDictProxy ): The parsed query parameters used for the request. text ( str ): The request body, as unicode-decoded. Must be awaited. url ( URL ): The parsed URL of the request. For more details, see Starlette docs . version ( str ): The HTTP version, like \"1.1\" , \"2\" .","title":"Instance attributes"},{"location":"api/models/http-py/#Request-methods","text":"accept def accept ( self , content_type : str ) -> Optional [ tuple [ str , float ]] Test given type is acceptable or not. Args content_type ( str ): Testing \"mime/type\" . Returns Optional[ tuple[str, float] ]: The first accepted type and its priority in the range: 0.0<=q<=1.0 , or None . media async def media ( self , parser : Callable [[ \"Request\" ], Awaitable [ Any ]] = None , parse_as : str = None , ) -> Union [ MultiDictProxy , Any ] Decode the request body to dict-like object. Must be awaited. You can use custom parser by setting your function. Args parser ( Optional[Callable[[Request], Awaitable[Any]]] ): Custom parser, must be async function. If not given, spangle uses builtin parser. parse_as ( Optional[str] ): Select parser to decode the body. Accept \"json\" , \"form\" , or \"multipart\" . Returns MultiDictProxy : May be overridden by custom parser. push async def push ( self , path : str ) -> None HTTP2 push-promise. Args path ( str ): A content location in the app.","title":"Methods"},{"location":"api/models/http-py/#Response","text":"class Response ( self , jinja_env : jinja2 . Environment = None , url_for = None ) Outgoing HTTP response class. Response instance is ASGI3 application. Attributes headers ( CIMultiDict ): The response headers, case-insensitive dictionary. To set values having same key, use headers.add() . cookies ( SimpleCookie ): Dict-like http cookies. Set-Cookie header refers this. You can set cookie-attributes. status ( int ): The response\u2019s status code. streaming ( Optional[AsyncGenerator] ): Async generator for streaming. If set, other response body attrs like media are ignored. mimetype ( str ): The mediatype of the response body. reraise ( bool ): In ErrorHandler, if set true, reraise the exception after sending data. Do not use manually.","title":"Response"},{"location":"api/models/http-py/#Response-attrs","text":"content ( bytes ): Bytes of the response body. Default-type: \"application/octet-stream\" . json ( Any ): A dict sent to the client. Default-type: \"application/json\" . You can set values like resp.json.keyName.you = \"want\" . text ( str ): A unicode string of the response body. Default-type: \"text/plain\" .","title":"Instance attributes"},{"location":"api/models/http-py/#Response-methods","text":"add_header def add_header ( self , key : str , value : str ) -> \"Response\" Append new header. To overwrite, use spangle.models.http.Response.set_header . Args key ( str ): Header\u2019s key. value ( str ): Header\u2019s value. Returns Response : Return self. delete_cookie def delete_cookie ( self , key : str , path : str = \"/\" , domain : str = None ) -> \"Response\" Remove cookie value from client. Args key ( str ) Cookie options: path ( str ) domain ( str ) Returns Response : Return self. load_template async def load_template ( self , template_name : str , content_type = \"text/html\" , ** params ) -> \"Response\" Load jinja2 template, render, set headers & text. Args template_name ( str ): The template \"path/name\" . content_type ( str ): \"text/html\" . **params : Variables used in the template. api is reserved by Api instance by default. Returns Response : Return self. Raises ValueError : Missing jinja2 env in Api instance. NotFoundError : Missing requested template. redirect def redirect ( self , * , view : type = None , params : dict = None , url : str = None , status = HTTPStatus . TEMPORARY_REDIRECT , query_string : Optional [ str ] = None , ) -> \"Response\" Set redirect view/location. Positional args are not allowed. If both view and url are set, url is ignored. Args view ( Type ): View class that the client redirect to. params ( dict ): Dynamic URL params passed to the view. url ( str ): The location out of the app. status ( int ): HTTP status code. Must be 300<=status<400 . Returns Response : Return self. set_content def set_content ( self , content : bytes , content_type = \"application/octet-stream\" ) -> \"Response\" Set bytes to response body with content type. Args content ( bytes ): Response body as bytes. content_type ( str ): Response content type. Returns Response : Return self. set_cookie def set_cookie ( self , key : str , value : str = \"\" , max_age : Optional [ int ] = None , expires : Optional [ int ] = None , path : Optional [ str ] = \"/\" , comment : Optional [ str ] = None , domain : Optional [ str ] = None , secure : bool = False , httponly : bool = True , version : Optional [ int ] = None , samesite : Optional [ str ] = \"Lax\" , ) -> \"Response\" Set cookie value to given key with params. Args key ( str ) value ( str ) Cookie options: max_age ( Optional[int] ) expires ( Optional[int] ) path ( Optional[str] ) comment ( Optional[str] ) domain ( Optional[str] ) secure ( bool ) httponly ( bool ) version ( Optional[int] ) samesite ( Optional[str] ) Returns Response : Return self. set_header def set_header ( self , key : str , value : str ) -> \"Response\" Set HTTP header value to given key. It overwrites value if exists. Args key ( str ): Header\u2019s key. value ( str ): Header\u2019s value. Returns Response : Return self. set_status def set_status ( self , status : int ) -> \"Response\" Set HTTP status code. Args status ( int ): HTTP status code. Returns Response : Return self. set_text def set_text ( self , text : str , content_type = \"text/plain\" ) -> \"Response\" Set given text to response body with content type. Args text ( str ): Response body as UTF-8 string. content_type ( str ): Response content type. Returns Response : Return self.","title":"Methods"},{"location":"api/models/websocket-py/","text":"Module spangle.models.websocket \u00b6 WebSocket connection. Classes \u00b6 Connection \u00b6 class Connection ( self , scope : Scope , receive : Receive , send : Send ) WebSocket connection to communicate with a client. Attributes state ( addict.Dict ): Any object you want to store while the connection. closed ( bool ): Whether connection is closed or not. reraise ( bool ): In ErrorHandler, if set true, reraise the exception after closing connection. headers ( CIMultiDictProxy ): The connection headers, case-insensitive dictionary. Do not use manually. Instance attributes \u00b6 params ( MultiDictProxy ): The parsed query parameters used for the request. url ( URL ): The parsed URL of the request. For more details, see Starlette docs . Methods \u00b6 accept async def accept ( self , subprotocol : str = None ) Allow client connection with subprotocol. Args subprotocol ( Optional[str] ): Subprotocol used for communication. close async def close ( self , status_code = 1000 ) Close the connection with status code. Args status_code ( int ): WebSocket status code. Default: 1000 . receive async def receive ( self , mode : Union [ type [ str ], type [ bytes ]]) -> Union [ str , bytes ] Receive data from the client. Args mode ( Union[type[str], type[bytes]] ): Receiving type, str or bytes . Returns Union[str, bytes] : Data with specified type. send async def send ( self , data : AnyStr ) Send data to the client. Args data ( AnyStr ): Data sent to the client, must be str or bytes .","title":"spangle.models.websocket"},{"location":"api/models/websocket-py/#module-spanglemodelswebsocket","text":"WebSocket connection.","title":"Module spangle.models.websocket"},{"location":"api/models/websocket-py/#classes","text":"","title":"Classes"},{"location":"api/models/websocket-py/#Connection","text":"class Connection ( self , scope : Scope , receive : Receive , send : Send ) WebSocket connection to communicate with a client. Attributes state ( addict.Dict ): Any object you want to store while the connection. closed ( bool ): Whether connection is closed or not. reraise ( bool ): In ErrorHandler, if set true, reraise the exception after closing connection. headers ( CIMultiDictProxy ): The connection headers, case-insensitive dictionary. Do not use manually.","title":"Connection"},{"location":"api/models/websocket-py/#Connection-attrs","text":"params ( MultiDictProxy ): The parsed query parameters used for the request. url ( URL ): The parsed URL of the request. For more details, see Starlette docs .","title":"Instance attributes"},{"location":"api/models/websocket-py/#Connection-methods","text":"accept async def accept ( self , subprotocol : str = None ) Allow client connection with subprotocol. Args subprotocol ( Optional[str] ): Subprotocol used for communication. close async def close ( self , status_code = 1000 ) Close the connection with status code. Args status_code ( int ): WebSocket status code. Default: 1000 . receive async def receive ( self , mode : Union [ type [ str ], type [ bytes ]]) -> Union [ str , bytes ] Receive data from the client. Args mode ( Union[type[str], type[bytes]] ): Receiving type, str or bytes . Returns Union[str, bytes] : Data with specified type. send async def send ( self , data : AnyStr ) Send data to the client. Args data ( AnyStr ): Data sent to the client, must be str or bytes .","title":"Methods"}]}